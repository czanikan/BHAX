<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <info>
        <title>Helló, Turing!</title>
        <keywordset>
            <keyword/>
        </keywordset>
    </info>
    <section>
        <title>1. Feladat: Végtelen ciklusok </title>
        <para>
            Egy mag kihasználása 100%-on:

            Két megoldás is készült a probléma feloldására. 
            A két általános végtelen ciklus ("while(true); és for(;;);") 
            <!--endlessWhile.c és endlessFor.c-->
            felhasználásával, de ezeket tekinthetjük akár csak egy féle ciklusként is,
            hiszen ha átfordítjuk őket assembly-re, akkor a két forráskódunk, 
            a nevén kívűl mindenben megegyezik.
            <!--endlessWhile.s és endlessFor.s--> 
            Na de miért használja ki egy mag százszázalékát?
            A válasz egyszerű. Azért mert egy mag egyszerre egy feladatot, tud ellátni, 
            de a feladatok közt nagyon gyorsan tud váltani. Viszont, ha egy végtelen ciklust
            kap szerencsétlen, akkor kénytelen annak feltételét folyamatosan ellenőrizni, így 
            nincs lehetősége, hogy váltson más feladatra vagy pihenjen.
            <!--screenshot: htop onecore100% -->
        </para>
        <para>
            Egy mag 0%-on:

            Hasonlóan indulunk el mint az előző esetén. Itt is megírjuk a kis végtelen ciklusunkat,
            viszont annyit módosítunk rajta, hogy adunk egy kis extra feladatot a processzornak 
            azon túl, hogy a feltételt ellenőrizgesse. 
            <!--endlessWhileSleep.c-->
            Ez lehet elsőre furcsán hangzik, de ha kap egy
            feladatott, ami méghozzá egy szüneteltetés ("sleep(1)") mégha csak egy nagyon kicsi 
            időintervallumig is, de van lehetősége megpihenni, ami a processzor magnak bőven elég is lesz.
            Ezért látjuk azt, hogy közel/teljesen 0%-on fut a mag.
            <!--screenshot: htop onecore0% -->
        </para>
        <para>
            Az összes mag 100%-on:

            Ha már játszunk a magokkal, akkor játszunk rendesen. All in!
            <!--endlessForAllCores.c-->
            Kicsit kiegészítjük a végtelen for ciklusunkat. Az első, hogy meghívjuk a megfelelő
            könyvtárat, ami jelen esetben az 'omp.h'. Erre azért lesz szükségünk, hogy parallax 
            programmá alakíthassuk a programunkat. A parallax programok lényege, minden minőségi 
            kifejtési igény nélkül, hogy kihasználja az összes erőforrást futtatáskor.
            Pontosan, ez kapóra is jön nekünk, mert ha már egy magot tudunk pörgetni maxon, akkor 
            így az összeset tudjuk majd. És láss csodát, valóban!
            <!--screenshot: htop allcores100%-->
        </para>
        <para>
            A legnagyobb tanulság amit levonhatunk ebből a rövid kisértleből, az nem más, mint hogy 
            a végtelen ciklusok ugyan hasznosak, de kilépési feltétel és megszakítás nélkül, rendesen
            el tudják foglalni a processzor magokat. Ami csak azért lehet problémás, mert akkor váltani
            se tudnak a feladatok között, amiből mi csak annyit érzékelünk, hogy gépünk nem végzi el a feladatát,
            sőt semmit se csinál, azaz lefagy.
            Ha lehet kerüljétek, de ha mindenképp kell, akkor is legyen benne feltétel a megszakításra.
        </para>
        <para>
            Megoldás videó: <link xlink:href="https://youtu.be/ittlesz">https://youtu.be/ittlesz</link>
        </para>
        <para>
            Megoldás forrása: <link xlink:href="Turing/infty-f.c">
                <filename>bhax/thematic_tutorials/bhax_textbook_IgyNeveldaProgramozod/Turing/infty-f.c</filename>
            </link>, 
            <link xlink:href="Turing/infty-w.c">
                <filename>bhax/thematic_tutorials/bhax_textbook_IgyNeveldaProgramozod/Turing/infty-w.c</filename>
            </link>.
        </para>
        <programlisting language="c"><![CDATA[int
main ()
{
  for (;;);
  return 0;
}
]]>
        </programlisting>        
        <para>        
        vagy az olvashatóbb, de a programozók és fordítók (szabványok) között kevésbé hordozható
        </para>
        <programlisting language="c"><![CDATA[int
#include <stdbool.h>
main ()
{
  while(true);
  return 0;
}
]]>
        </programlisting>                   
        <screen><![CDATA[$ 
            gcc -S -o infty-f.S infty-f.c 
            $ gcc -S -o infty-w.S infty-w.c 
            $ diff infty-w.S infty-f.S 
            1c1
            < 	.file	"infty-w.c"
            ---
            > 	.file	"infty-f.c"
        ]]>
        </screen>  
        <para>
            Egy mag 0 százalékban:               
        </para>        
        <programlisting language="c">
            <![CDATA[
            #include <unistd.h>
            int
            main ()
            {
            for (;;)
                sleep(1);
                
            return 0;
            }
            ]]>
        </programlisting>        
        <para>
            Minden mag 100 százalékban:               
        </para>

        <programlisting language="c">
            <![CDATA[
            #include <omp.h>
            int
            main ()
            {
            #pragma omp parallel
            {
            for (;;);
            }
            return 0;
            }
            ]]>
        </programlisting>        
        <para>
            A <command>gcc infty-f.c -o infty-f -fopenmp</command> parancssorral készítve a futtathatót, majd futtatva,               
            közben egy másik terminálban a <command>top</command> parancsot kiadva tanulmányozzuk, mennyi CPU-t használunk:            
        </para>
        <screen><![CDATA[top - 20:09:06 up  3:35,  1 user,  load average: 5,68, 2,91, 1,38
Tasks: 329 total,   2 running, 256 sleeping,   0 stopped,   1 zombie
%Cpu0 :100,0 us, 0,0 sy, 0,0 ni, 0,0 id, 0,0 wa, 0,0 hi, 0,0 si, 0,0 st
%Cpu1 : 99,7 us, 0,3 sy, 0,0 ni, 0,0 id, 0,0 wa, 0,0 hi, 0,0 si, 0,0 st
%Cpu2 :100,0 us, 0,0 sy, 0,0 ni, 0,0 id, 0,0 wa, 0,0 hi, 0,0 si, 0,0 st
%Cpu3 : 99,7 us, 0,3 sy, 0,0 ni, 0,0 id, 0,0 wa, 0,0 hi, 0,0 si, 0,0 st
%Cpu4 :100,0 us, 0,0 sy, 0,0 ni, 0,0 id, 0,0 wa, 0,0 hi, 0,0 si, 0,0 st
%Cpu5 :100,0 us, 0,0 sy, 0,0 ni, 0,0 id, 0,0 wa, 0,0 hi, 0,0 si, 0,0 st
%Cpu6 :100,0 us, 0,0 sy, 0,0 ni, 0,0 id, 0,0 wa, 0,0 hi, 0,0 si, 0,0 st
%Cpu7 :100,0 us, 0,0 sy, 0,0 ni, 0,0 id, 0,0 wa, 0,0 hi, 0,0 si, 0,0 st
KiB Mem :16373532 total,11701240 free, 2254256 used, 2418036 buff/cache
KiB Swap:16724988 total,16724988 free,       0 used. 13751608 avail Mem 
  PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND     
 5850 batfai    20   0   68360    932    836 R 798,3  0,0   8:14.23 infty-f     
]]></screen>  

    </section>        
        
    <section>
        <title>2. Feladat: Lefagyott, nem fagyott, akkor most mi van?</title>
        <para>
            Megoldás forrása:  tegyük fel, hogy akkora haxorok vagyunk, hogy meg tudjuk írni a <function>Lefagy</function>
            függvényt, amely tetszőleges programról el tudja dönteni, hogy van-e benne vlgtelen ciklus:              
        </para>
        <programlisting language="c"><![CDATA[Program T100
{
	boolean Lefagy(Program P)
	{
		 if(P-ben van végtelen ciklus)
			return true;
		 else
			return false; 
	}
	main(Input Q)
	{
		Lefagy(Q)
	}
}]]></programlisting>            
        <para>
            A program futtatása, például akár az előző <filename>v.c</filename> ilyen pszeudókódjára:
            <screen><![CDATA[T100(t.c.pseudo)
true]]></screen>            
            akár önmagára
            <screen><![CDATA[T100(T100)
false]]></screen>  
            ezt a kimenetet adja.          
        </para>
        <para>
            A T100-as programot felhasználva készítsük most el az alábbi T1000-set, amelyben a
            Lefagy-ra épőlő Lefagy2 már nem tartalmaz feltételezett, csak csak konkrét kódot:
        </para>
        <programlisting language="c"><![CDATA[Program T1000
{
	boolean Lefagy(Program P)
	{
		 if(P-ben van végtelen ciklus)
			return true;
		 else
			return false; 
	}
	boolean Lefagy2(Program P)
	{
		 if(Lefagy(P))
			return true;
		 else
			for(;;); 
	}
	main(Input Q)
	{
		Lefagy2(Q)
	}
}]]></programlisting>            
        <programlisting><![CDATA[]]></programlisting>            
        <para>
            Mit for kiírni erre a <computeroutput>T1000(T1000)</computeroutput> futtatásra?
                                
            <itemizedlist>
                <listitem>
                    <para>Ha T1000 lefagyó, akkor nem fog lefagyni, kiírja, hogy true</para>                        
                </listitem>
                <listitem>
                    <para>Ha T1000 nem fagyó, akkor pedig le fog fagyni...</para>                        
                </listitem>
            </itemizedlist>
            akkor most hogy fog működni? Sehogy, mert ilyen <function>Lefagy</function>
            függvényt, azaz a T100 program nem is létezik.                
        </para>
        <para>
            A fő probléma abban rejlik, hogy az if-else ágban egy ellentmondásba ütközünk. Mivel ha a P programban van 
            végtelen ciklus, akkor a <function>Lefagy2</function> egy true értékkel, ellenben ha meg nincs benne, akkor
            visszatérne egy további for ciklussal, hogy tovább figyeljen, ami viszont ahhoz vezet, hogy akkor már lesz benne
            végtelen ciklus. Tehát ha nem fagyott le eddig, akkor mostmár le fog.
        </para>
        <para>
            Szerencsére sok modern IDE-ban van olyan kisegítő lehetőség, mely figyelmeztet minket arra, ha programunk olyan
            végtelen ciklust tartalmaz, melynek nincs kilépési feltétele. Ez sokat segíthet, de még így is könnyen megtörténhet
            hogy figyelmetlenség miatt benne marad. És mivel ez csak egy figyelmeztetés és nem hibaüzenet, ezért a program 
            fordítható és futtatható, így lehet jó ideig elő se jön a probléma.
        </para>
    </section>        
                
    <section>
        <title>3. Feladat: Változók értékének felcserélése</title>
        <para>
            Az alábbi programban három általános módját tekinthejük meg a változók közti értékcserének.
            A használat könnyítése érdekében, ez tartalmaz egy <command>switch</command> utasítást, hogy könnyen
            kiválaszthassuk, hogy melyik módszert szeretnénk alkalmazni
        </para>
        <para>
            <programlisting language="c"><![CDATA[#include <stdio.h>
                #include <stdlib.h>
                int main()
                {
                    int a = 0;
                    int b = 0;
                    int tmp = 0;
                    int choice;
                    while(1)
                    {
                        printf("a = ");
                        scanf("%d",&a);
                        printf("\nb = ");
                        scanf("%d",&b);
                        printf("\n---x{[MENU]}x---\n");
                        printf("1 - Seged valtozoval\n");
                        printf("2 - Kivonassal\n");
                        printf("3 - Osszeadassal\n");
                        printf("9 - Exit\n");
                        fflush(stdin);
                        scanf("%d",&choice);
                
                        switch(choice)
                        {
                            case 1:
                                tmp = a;
                                a = b;
                                b = tmp;
                                printf("a = %d, b = %d\n", a, b);
                                break;
                
                            case 2:
                                a = a - b;
                                b = a + b;
                                a = b - a;
                                printf("a = %d, b = %d\n", a, b);
                                break;
                
                            case 3:
                                a = a + b;
                                b = a - b;
                                a = a - b;
                                printf("a = %d, b = %d\n", a, b);
                                break;
                
                            case 9:
                                break;
                            default:
                                printf("Invalid bemenet!\n");
                        }
                        break;
                    }
                    return 0;
                }]]></programlisting>
        </para>
        <para>
            Nézzük meg a három értékcserét egyesével: 
        </para>
        <programlisting language="c"><![CDATA[
                tmp = a;
                a = b;
                b = tmp;
                printf("a = %d, b = %d\n", a, b);
                break;
            ]]></programlisting>
        <para>
            A segédváltós értékcserét egy egyszerű példával szemléltetném: Van az asztalon egy pohár almalé és egy 
            pohár narancslé és szeretnénk a két pohár tartalmát felcserélni. Ez a feladat így nem más mint egy 
            gordiuszi csomó. De mielőtt pánikba esünk, hívjunk segítségül egy harmadik, de üres poharat. Ez a pohár lesz
            a segédváltozónk, vagy jelen esetben segédpoharunk. Ha a segédpohárba átöntjük az almalevet, akkor az a pohár üres lesz,
            így abba átönthetjük a narancslevet. Ami által a narancsleves pohár is felszabadúl. Ezután a segédpohárból beleönthetjük
            az almalevet az immár üres pohárba. Egyszerű, nem igaz?
        </para>
        <programlisting language="c"><![CDATA[
            a = a - b;
            b = a + b;
            a = b - a;
            printf("a = %d, b = %d\n", a, b);
            break;
        ]]></programlisting>
        <para>
            A segédváltozós értékcserével ellentétben ezt a kettőt csak számokkal tudjuk alkalmazni, mivel például a <type>sztringek</type> vagy <type>boolenek</type> kivonása és összeadása
            nem igazán értelmezhető. Itt a kivonásos példában azzal kezdjük, hogy az <varname>a</varname>-ból kivonjuk a <varname>b</varname>-t. A <varname>b</varname>-hez hozzáadjuk az <varname>a</varname>-t
            , ezzel kiegészítve, tehát megkapjuk az <varname>a</varname> értéket és végül <varname>b</varname>-ből kivonjuk az <varname>a</varname>-t és kész is vagyunk. 
        </para>
        <programlisting language="c"><![CDATA[
            a = a + b;
            b = a - b;
            a = a - b;
            printf("a = %d, b = %d\n", a, b);
            break;
        ]]></programlisting>
        <para>
            Végül az összeadásos: <varname>a</varname>-hoz hozzáadjuk <varname>b</varname>-t, tehát tartalmazza mindkét értéket. Utánna <varname>b</varname>-nél kivonjuk <varname>a</varname>-ból 
            önmagát, így már csak az eredeti <varname>a</varname>-t tartalmazza. Végül az <varname>a</varname>-t is meghatározzuk, úgy hogy kivonjuk belőle a <varname>b</varname>-t, ami ugye az új <varname>a</varname> 
            , tehát az új <varname>b</varname> lesz. Kicsit katyvasz, de csak egyszer kell megérteni és követhető lesz. 
        </para>

    </section>                     

    <section>
        <title>4. Feladat: Labdapattogás</title>
        <para>
            Először if-ekkel, majd bármiféle logikai utasítás vagy kifejezés
            nasználata nélkül írj egy olyan programot, ami egy labdát pattogtat a karakteres konzolon! (Hogy mit értek
            pattogtatás alatt, alább láthatod a videókon.)
        </para>
        <para>
            Megoldás forrása:
        </para> 
        <para>
            Fordítás: 
        </para>
        <screen>gcc bouncyO.cpp -o bouncyO -lncurses</screen>
        <para>
            Eleve az adott példa alapján megírtam a program if-es változatát, mely kommentként szerepel a forrásban.
            Ezután az if nélküli verzióban az if-ek feladatát kiszerveztem for ciklusoknak, melyek csak akkor lépnek életbe, ha a 
            '(DVD)' karakter eléri az ablak valamelyik szélét, majd ez alapján x vagy y értékét negatív előjelüvé cseréljük, azaz 
            visszapattinjuk a falról. Kicsit hasonlít a technika arra mint amit az Atari Blockbreaker játékában is alkalmaztak, hogy
            visszapattanjon a labda a játékosról, azzal a kis extrával, hogy ott vektorokat alkalmaztak, így a vektor hossz alapján
            lehetet kicsit befolyásolni a visszapattanási szöget. Egyszerű megoldás, de így nem volt olyan statikus és kiszámítható
            a labda új íránya, ezzel változatosabbá téve a játékot.
            Mellesleg az én példámban 'o' helyett a '(DVD)' szerepel, mivel kisebb koromban szerettem nézni a DVD lejátszókon
            a képernyőkimélőt, melyen a felirat minden visszapattanás után színt váltott. Ezt egy kis "easteregg"-nek szántam.
        </para>
        <programlisting language="c"><![CDATA[
            #include <stdio.h>
            #include <curses.h>
            #include <unistd.h>
            int main()
            {
                WINDOW *ablak;
                ablak = initscr();
                int x = 0;
                int y = 0;
                int delX = 1;
                int delY = 1;
                int mx;
                int my;
                
                while(true)
                {
                    printf("\033[0;32m");
                    getmaxyx(ablak, my, mx);
                    mvprintw(y, x, "(DVD)");
                    refresh();
                    usleep(100000);
                    
                    clear();
                    x = x + delX;
                    y = y + delY;
                ]]>
        </programlisting> 
        <para>
            Először behívjuk a kellő könyvtárakat, felvesszük a változókat és közben az <varname>ablak</varname>-ban inicializáljuk a terminál ablakot, 
            amit majd a <function>getmaxyx()</function> függvényben meghatározzuk, az ablak maximális szélességét és magasságát. Ez ugye elengedhetetlen egy 
            labdapattogtatós program esetén. Továbbá mivel a while-on belül van, így az ablak méretváltoztatására is jól reagál, mondhatni rekurzív megjelenítést 
            érünk el. Ezen kívűl a <function>mvprintw()</function> függvény pedig felel a kis DVD felíratunk kirajzolásáért az adott x és y koordinátákon. 
        </para>
        <programlisting language="c"><![CDATA[
                    /*
                    if(x <= 0)
                    {
                        delX = delX * -1;
                        //printf("\033[0;31m");
                    }
                    if(x >= mx-1)
                    {
                        delX = delX * -1;
                        //printf("\033[0;32m");
                    }
                    if(y <= 0)
                    {
                        delY = delY * -1;
                        //printf("\033[0;33m");
                    }
                    if(y >= my-1)
                    {
                        delY = delY * -1;
                        //printf("\033[0;34m");
                    }
                    */
                    for(;x <= 0;)
                    {
                        delX = delX * -1;
                        break;
                    }
                    for(;x >= mx-1;)
                    {
                        delX = delX * -1;
                        break;
                    }
                    for(;y <= 0;)
                    {
                        delY = delY * -1;
                        break;
                    }
                    for(;y >= my-1;)
                    {
                        delY = delY * -1;
                        break;
                    }
                }
                return 0;
            }]]></programlisting> 
        <para>
            Maga a visszapattanás pedig pofon egyszerű. Megnézzük hogy melyik szélét érte el az ablaknak. Itt ugye sok lehetőség nincs, csak négy. Ezt ugye 
            a felírat koordinátáival és az ablak maximális méretinek a segítségével tesszük meg (itt kihasználjuk, hogy a bal szél az x = 0, az alja meg az y = 0). Ha elérte egyszerűen 
            megfordítjuk a menetirányát, ugy hogy az ezért felelős <varname>delX</varname>-nek és <varname>delY</varname>-nak megcseréljük az előjelét (laikusoknak: megszorozzuk (-1)-el). 
        </para>
        <para>
            Ezeket meg ismételjük a végtelenségig, vagy legalábbis a megunásig. Mondjuk én kiskoromban huzamosabb ideig is el tudtam nézni, várva hogy hátha más szögbe pattan vissza, 
            de hiába, nem lehet minden Pong... 
        </para>
    </section>                     
    <section>
        <title>5. Feladat: Szóhossz és a Linus Torvalds féle BogoMIPS</title>
        <para>
            Írj egy programot, ami megnézi, hogy hány bites a szó a gépeden, azaz mekkora az <type>int</type> mérete.
            Használd ugyanazt a while ciklus fejet, amit Linus Torvalds a BogoMIPS rutinjában! 
        </para>
        <para>
            Megoldás videó: <link xlink:href="https://youtu.be/9KnMqrkj_kU">https://youtu.be/9KnMqrkj_kU</link>, 
            <link xlink:href="https://youtu.be/KRZlt1ZJ3qk">https://youtu.be/KRZlt1ZJ3qk</link>, 
            <link xlink:href=""></link>.
        </para>
        <para>
            Megoldás forrása: <link xlink:href="Turing/bogomips.c">
                <filename>bhax/thematic_tutorials/bhax_textbook_IgyNeveldaProgramozod/Turing/bogomips.c</filename>
            </link>
        </para>
        <para>
            Nyílván nem én vagyok az egyetlen aki korábban nem hallott még a BogoMIPS-ről, de ezzel alapvetőleg nincs is baj. Két kifejezés játékos összemosásából jött létre: Bogus (kamu, nem valódi) 
            és MIPS, ami két dolognak is a rövidítése. Az első a tudományosan hangzó: Millions of Instructions per Second (másodpercenként végrehajtott műveletek millióban) és a második, de találóbb 
            jelentése: Meaningless Indication of Processor Speed (értelmetlen jellemzése a processzor sebességének). Ez mutatja is, hogy ez inkább egy vicces apróság, mint egy komoly és pontos teszt, 
            de azért elemzése megér egy misét. Egyébként már valószínűleg mindenki találkozott ezzel, bár esélyes hogy nem vette észre, vagy csak jelentéktelen random karaktereknek vette, mint a többi 
            hardware checket bootoláskor, mintha csak valami mátrix easter egg lenne... 
        </para>
        <para>
            Alapvetőleg egy ehhez hasonló értéket kell kapnunk: 
        </para>
        <screen>
            <![CDATA[   
            386SX         clock * 0.14
            386DX         clock * 0.18
            486Cyrix/IBM  clock * 0.33
            486SX/DX/DX2  clock * 0.50
            586           clock * 0.39
            ]]>
        </screen>
        <para>
            Ha ennél jóval kisebbet mutat a gépünk akkor érdemes ránézni a CPU beállításokra, vagy a cache-re. 
            Itt még meg kell jegyezni, hogy a BogoMIPS érték igazából két dologra jó. Le lehet ellenőrizni, hogy a processzor a beállításainak megfelelően működik és persze lehet izmozni a 
            haveroknak, hogy kinek mekkora... 
        </para>
        <para>
            A program lényege, hogy bináris eltolással végig lépkedjünk egy <type>long long</type> típusú változón,
            miközben mérjük, hogy mennyi ideig tart ez neki. Ezután a kapott hatalmas számot el kell osztanunk egy
            számmal (ez egy tetszőleges szám lehet, a cél csak az, hogy az eredmény 100-1000 között legyen).
            Ennek a számnak nincs mértékegysége, de ha összehasonlítjuk más gépek értékével, melyeken ugyan ezt a programot
            futtatjuk, akkor egyszerűen megállapítható, hogy melyik gép processzora számít gyorsabban.
        </para>
        <para>
            Ha a program while() ciklusa előtt létrehozunk egy változót és ennek értékét ciklus futásonként 
            növeljük, akkor visszakapjuk a <type>long long</type> típus méretét bitben.
        </para>
        <programlisting language="c">
            <![CDATA[
            #include <stdio.h>

                int main()
                {
                    int wordLength = 0, word = 1;
                    
                    do
                    {
                        
                        wordLength++;
                        
                    } while(word <<= 1);
                    
                    printf("A szó ezen a gépen %d bites\n", wordLength);
                    
                    return 0;
                }
            ]]>
        </programlisting> 
        <para>
            A szóhossz program is nagyon hasonló csak ez még egyszerűbb alapvetőleg. Bitenként lépkedünk és minden lépésnél növeljük a <varname>wordLength</varname>-et, azaz megszámoljuk lényegében 
            a bitjeit. Így megkapván a szóhosszt: 
        </para>
        <screen>
            <![CDATA[ 
            A szó ezen a gépen 32 bites
            ]]>
        </screen>
    </section>                     

    <section>
        <title>6. Feladat: Helló, Google!</title>
        <para>
            Írj olyan C programot, amely egy 4 honlapból álló hálózatra kiszámolja a négy lap Page-Rank 
            értékét!
        </para>
        <para>
            Megoldás videó: <link xlink:href=""></link>
        </para>
        <para>
            Megoldás forrása: <link xlink:href=""></link>
        </para>
        <para>
            Nevét Larry Page után kapta, a Google cégóriás egyik alapítójáról. Úgy gondolták, hogy a keresési szó szerepelésén túl 
            úgy lehetne legjobban rangsorolni az oldalakat, hogyha a rájuk mutató oldalak száma és minősége szerint rangsorolnák a 
            találatokat. Az ötlet mögött az a feltételezés ált, hogyha megbízható oldalak hivatkozzák meg az adott oldalt, akkor 
            lényegében azok az oldalak validálják annak megbízhatóságát és növelik annak az esélyét, hogy a keresett tartalom előre kerül. 
            Valószínűleg igazuk is lett, mert a Google ezáltal hamar a legnépszerűbb keresőmotorrá vált. 
        </para>
        <para>
            Az algoritmus alapból (0. iteráció) minden oldalnak azonos pageranket határoz meg (1/N, ahol N a lapok száma). 
            Ezután a rá mutató lapok előző iterációban kiszámítóttot pagerankjét elosztjuk a rá mutató lapok számával. 
            Könnyen észrevehető, hogy ezt a végtelenségig csinálhatnánk.   
        </para>
        <para>
            Ennek kiküszöbölésére hivatott a damp factor bevezetése. Igazából nem ez a fő célja, hanem a Sztochasztikus szörföző metódushoz 
            szükséges, ami azt próbálja szimulálni, hogy a weben véletlen szerűen nézelődő felhasználó milyen valószínűséggel talál rá az oldalra. 
            De sokat segít hogy a számításaink ne menjenek a végtelenségig. 
        </para>
        <para>
            <programlisting language="c"><![CDATA[
                #include <stdio.h>
                #include <stdlib.h>
                #include <math.h>
                
                double distance (double PR[], double PRv[], int db)
                {
                    double dist = 0.0;
                    for(int i = 0; i < db; i++)
                    {
                        dist += pow((PRv[i] - PR[i]), 2);
                    }
                    return sqrt(dist);
                }
                
                void kiir (double list[], int db)
                {
                    for(int i = 0; i < db; i++)
                    {
                        printf("PageRank [%d]: %lf\n", i, list[i]);
                    }
                }
                ]]></programlisting>
        </para>
        <para>
            Behívjuk először a szükséges könyvtárakat, mint például a <varname>math.h</varname>-t, amit a következő bekezdésben fogok részletezni. 
        </para>
        <para>
            A <function>distance()</function> függvényről külön elméláznék. Az eredeti terv az volt, hogy <function>abs()</function> segítségével a különbség abszolút értékével számolok. 
            De ezt pár hibás futtatás után ki kellett, hogy szedjem, mivel mint kiderült, C-ben ez csak <type>int</type> típust tud kezelni, azaz egész számokat. Viszont a <varname>PR</varname> 
            és <varname>PRv</varname> is <type>double</type> típus így nem lenne szerencsés konvertálni. Így kénytelen vagyok a négyzetértékkel számolni, majd végül abból gyököt vonni, ami ugyan azt 
            az eredményt adja, hogy csak pozitív értéket vehet fel vagy nullát (mivel hogy két negatív szám szorzata pozitív, az pedig nem fordulhat elő, hogy egyik negatív míg a másik pozitív, hisz
            ugyan az a művelet). Megjegyzem, hogy az előbb említett két függvény indokolja a <varname>math.h</varname> headert és a -lm kapcsolót a fordításhoz. 
        </para>
        <para>
            Van még itt egy <function>kiir()</function>, de ez csak szimplán kiiratja a 4 darab oldal pagerank értékét. 
        </para>
        <programlisting language="c"><![CDATA[
            int main(void)
            {
                double L[4][4] = 
                {
                {0.0, 0.0, 1.0/3.0, 0.0},
                {1.0, 1.0/2.0, 1.0/3.0, 1.0},
                {0.0, 1.0/2.0, 0.0, 0.0},
                {0.0, 0.0, 1.0/3.0, 0.0}
                };
            
                double PR[4] = {0.0, 0.0, 0.0, 0.0};
                double PRv[4] = {1.0/4.0, 1.0/4.0, 1.0/4.0, 1.0/4.0};
            
                for(;;)
                {
                    for(int i = 0; i < 4; i++)
                    {
                        PR[i] = PRv[i];
                    }
                    for(int i = 0; i < 4; i++)
                    {
                        PRv[i] = 0;
                        for(int j = 0; j < 4; j++)
                        {
                            PRv[i] += L[i][j] * PR[j];                
                        }
                    }
                    if(distance(PR, PRv, 4) < 0.00001)
                    {
                        break;
                    }
                }
                kiir (PR, 4);
                return 0;
            }
            ]]></programlisting>
        <para>
            Itt először nézzük meg miből élünk. Van itt egy <varname>L</varname> szükszavú elnevezésű <type>double</type> típusú mátrixunk, mely a linkeket tartalmazza. Van még nekünk két szintén 
            <type>double</type> típusú tömbünk <varname>PR</varname> és <varname>PRv</varname> néven. Ezek a pagerank értéket tartalmazzák, az egyik a jelenlegit (<varname>PR</varname>), a másik 
            az iteráció előző körében szereplő pagerank értékét mutatja az oldalinknak (<varname>PRv</varname>).
        </para>
        <para>
            A következő rész a végtelenciklusunk, ahol a munka oroszlánrésze zajlik.
        </para>
        <programlisting language="c"><![CDATA[
                    for(int i = 0; i < 4; i++)
                    {
                        PR[i] = PRv[i];
                    }
            ]]>
        </programlisting>
        <para>
            Itt egyszerűen átadjuk a pagerank értékeket az előző körből a jelenleginek (ezért fontos, hogy a <varname>PRv</varname>-nek legyen kezdőértéke).
        </para>
        <programlisting language="c"><![CDATA[
            for(int i = 0; i < 4; i++)
                    {
                        PRv[i] = 0;
                        for(int j = 0; j < 4; j++)
                        {
                            PRv[i] += L[i][j] * PR[j];                
                        }
                    }
            ]]>
        </programlisting>
        <para>
            Itt következik egy dupla for ciklus. Ez azért fontos mert itt mátrixal fogunk dolgozni, ami ugye egy két dimenziós tömb. Először lenullázzuk a <varname>PRv</varname>-t, majd 
            új értéket adunk neki, azáltal, hogy a jelenlegi <varname>PR</varname> minden elemét összeszorozzuk az <varname>L</varname> linkmátrixal (mátrix szorzása vektorral). 
        </para>
        <programlisting language="c"><![CDATA[
            if(distance(PR, PRv, 4) < 0.00001)
                    {
                        break;
                    }
                }
                kiir (PR, 4);
                return 0;
            ]]>
        </programlisting>
        <para>
            Végül de nem utolsó sorban ez az <type>if</type>. Az elején taglaltam, hogy ez a számítás a végtelenig mehetne és hogy ezt elkerüljük felhasználjuk a damp factort (a 0.00001 az). 
            Tehát ha a <function>distance()</function> értéke eléggé megközelíti a nullát akkor egyszerűen megszakítjuk a végtelen ciklust (break) és kiírjuk az eredményt a felhasználónak.  
        </para>
        <para>
            Fordítás: <screen>gcc PageRank.c -o pr -lm</screen>
        </para>
        <para>
            Kimenet: 
            <screen>
                <![CDATA[ 
                PageRank [0]: 0.090907
                PageRank [1]: 0.545460
                PageRank [2]: 0.272725
                PageRank [3]: 0.090907
                ]]>
            </screen>
        </para>
    </section>
                                                                                                                                                                                                                                                                                                                                                        
    <section xml:id="bhax-textbook-feladatok-turing.MontyHall">
        <title>A Monty Hall probléma</title>
        <para>
            Írj R szimulációt a Monty Hall problémára!
        </para>
        <para>
            Megoldás videó: <link xlink:href="https://bhaxor.blog.hu/2019/01/03/erdos_pal_mit_keresett_a_nagykonyvben_a_monty_hall-paradoxon_kapcsan">https://bhaxor.blog.hu/2019/01/03/erdos_pal_mit_keresett_a_nagykonyvben_a_monty_hall-paradoxon_kapcsan</link>
        </para>
        <para>
            Megoldás forrása: <link xlink:href="https://gitlab.com/nbatfai/bhax/tree/master/attention_raising/MontyHall_R">https://gitlab.com/nbatfai/bhax/tree/master/attention_raising/MontyHall_R</link>
        </para>
        <para>
            A Monty Hall paradoxon nevét a Monty Hall Show (és műsorvezetője akit meglepő mód szintén így hívtak) után 
            kapta. A probléma megértéséhez vázolnám röviden a műsor menetét:
            Adott volt három ajtó. Az egyik ajtó mögött egy méregdrága sportkocsi volt, míg a másik kettő mögött egy-egy
            kecske. A játékosnak nem volt más dolga mint megtippelnie, hogy melyik ajtó rejti a mesés fődíjat.
            Miután a játékos megtette a voksát, utánna Monty feltárta a maradék két ajtó közül az egyiket amelyik kecsét rejtett
            és lehetőséget adott a játékosnak az újraválasztásra.
            Na de joggal kérdezhetnénk, hogy hol ebben a paradoxon. A probléma ott kezdődött mikor előkerültek a műsor statisztikái,
            miszerint akik újra választottak ajtót, miután Monty felfedte az egyik ajtó titkát, azok majdnem kétszer olyan gyakran
            nyertek, mint akik nem.
        </para>
        <para>
            Amikor elsőnek választ ajtót a játékos, az egy egyszerű valószínűség számítási probléma, hiszen három ajtónk van,
            de csak egy fődíj, azaz minden ajtónak 1/3 esélye van, hogy az autót rejti. Lényegében mindegy melyik ajtót választja
            az ember. A probléma gyökere abból adódik, hogy mikor Monty választ egy ajtót ami mögött ő tudja, hogy kecske lesz és
            felkinálja az újraválasztás lehetőségét, a dolgok nem úgy folytatódnak ahogy az logikus lenne (legalábbis a statisztika szerint).
            Ugyebár logikusan azt gondolnánk, hogy maradt két ajtó, az egyik mögött még mindig ott a díj, mindkét ajtónak ugyan annyi esélye van
            (50%-50%), tehát felesleges lenne újat választani. Viszont ahogy azt az analitika mutatja, a dolgok nem így mennek, 
            hanem az ajtók esélyei, maradnak az eredetiek, viszont mikor Monty felfedi az egyik ajtót, akkor viszont annak az esélyei,
            átszállnak a megmaradt ajtóra, amivel jelentősen romlanak eredeti esélyeink (1/3:2/3).
        </para>
        <programlisting language="R">
            <![CDATA[
            trials=1000000
            trial = sample(1:3, trials, replace=T)
            player = sample(1:3, trials, replace=T)
            host=vector(length = trials)

            for (i in 1:trials) 
            {

                if(trial[i]==player[i])
                {
                
                    leftOver=setdiff(c(1,2,3), trial[i])
                
                }
                else
                {
                
                    leftOver=setdiff(c(1,2,3), c(trial[i], player[i]))
                
                }

                host[i] = leftOver[sample(1:length(leftOver),1)]

            }

            stayingChance= which(trial==player)
            changingVec=vector(length = trials)

            for (i in 1:trials) 
            {

                changeIndexes = setdiff(c(1,2,3), c(host[i], player[i]))
                changingVec[i] = changeIndexes[1]
                
            }

            changingChance = which(trial==changingVec)


            sprintf("Kiserletek szama: %i", trials)
            length(stayingChance)
            length(changingChance)
            length(stayingChance)/length(changingChance)
            length(stayingChance)+length(changingChance)
                        ]]>
    </programlisting>
    <para>
        Daraboljuk fel egy kicsit: 
    </para>
    <programlisting language="R">
        <![CDATA[ 
        trials=1000000
        trial = sample(1:3, trials, replace=T)
        player = sample(1:3, trials, replace=T)
        host=vector(length = trials)
        ]]>
    </programlisting>
    <para>
        Beállítjuk a kisérletek számát egymillióra, majd kisorsoljuk a nyertes ajtót és a játékos tippjét (nem egyet, hanem 1000000 darabot) majd elkészítünk egy vektort. Ezután jön a játék első 
        köre: 
    </para>
    <programlisting language="R">
        <![CDATA[
        for (i in 1:trials) 
        {

            if(trial[i]==player[i])
            {
            
                leftOver=setdiff(c(1,2,3), trial[i])
            
            }
            else
            {
            
                leftOver=setdiff(c(1,2,3), c(trial[i], player[i]))
            
            }

            host[i] = leftOver[sample(1:length(leftOver),1)]

        }
        ]]>
    </programlisting>
    <para>
        Megvizsgálunk két eshetőséget mielőtt feltárunk egy ajtót. Az első hogy a játékos bár nem tudja, de telibe eltalálta a nyertes ajtót, ilyenkor a fennmaradt két ajtó kerül a listánkra, 
        mint hátralévő. 
        A második, hogy másik ajtóra tippelt, ilyenkor egyszerűen a harmadik, még egyik fél által sem választott ajtót használjuk. Ehhez mindkét esetben a <function>setdiff()</function> függvényt 
        alkalmazzuk, amely a matematikai halmaz elmélet alapján két halmaz különbségét határozza meg. Ezeket az ajtókat eltároljuk a <varname>leftOver</varname>-be, hogy majd a <varname>host</varname>-ban 
        kiválasztjuk hogy a maradék egy vagy két ajtó közül melyiket fedjük fel jelképesen, azaz melyik esik ki a játékból. 
    </para>
    <programlisting language="R">
        <![CDATA[
            stayingChance= which(trial==player)
            changingVec=vector(length = trials)

            for (i in 1:trials) 
            {

                changeIndexes = setdiff(c(1,2,3), c(host[i], player[i]))
                changingVec[i] = changeIndexes[1]
                
            }

            changingChance = which(trial==changingVec)
        ]]>
    </programlisting>
    <para>
        A <varname>stayingChance</varname>-be eltároljuk, hogy az összes esetből hányszor nyernénk, ha nem változtatunk, tehát ha elsőre eltatlájuk. Aztán egy forciklusban végig megyünk az összes eseten 
        és megnézzük, hogy mi lesz akkor ha ajtót váltunk. Az új ajtó indexe a <varname>changeIndexes</varname>-be kerül, azáltal, hogy megnézzük, hogy melyik az az ajtó, ami megmarad, ha kivesszük a 
        választott ajtónkat és a feltárt ajtót. Majd a <varname>changingVec</varname> vektorban eltároljuk ezeket az indexeket. 
        Végül a <varname>changingChance</varname>-ben megvizsgáljuk, hogy ajtócserével hány esetben nyernénk. 
    </para>
    <programlisting language="R">
        <![CDATA[
        sprintf("Kiserletek szama: %i", trials)
        length(stayingChance)
        length(changingChance)
        length(stayingChance)/length(changingChance)
        length(stayingChance)+length(changingChance)
        ]]>
    </programlisting>
    <para>
        Végül pedig kiíratjuk a kapott eredményeket. Először kiírjuk a kísérletek számát, majd hogy hány esetben nyert az ajtó váltás nélküli (length(stayingChance)). Ezután jön hogy hány esetben 
        nyert az ajtóváltással (length(changingChance)). Végül pedig kis ellenörzésként össze van hasonlítva, hogy az első érték majdnem a fele a másodiknak és hogy a kettő összege valóban egyezik 
        a kísérletek számával. 
    </para>
	<para>
		Lássuk a futtatást:
	</para>
	<screen>
        <![CDATA[ 
        [1] "Kiserletek szama: 1000000"
        [1] 333982
        [1] 666018
        [1] 0.5014609
        [1] 1000000
        ]]>
	</screen>
        
    </section>

    <section xml:id="Brun">
        <title>100 éves a Brun tétel</title>
        <para>
            Írj R szimulációt a Brun tétel demonstrálására!
        </para>
        <para>
            Megoldás videó: <link xlink:href="https://youtu.be/xbYhp9G6VqQ">https://youtu.be/xbYhp9G6VqQ</link>
        </para>
        <para>
            Megoldás forrása: <link xlink:href="https://gitlab.com/nbatfai/bhax/blob/master/attention_raising/Primek_R">https://gitlab.com/nbatfai/bhax/blob/master/attention_raising/Primek_R</link>
        </para>
        <para>
            A Brun tétel röviden azt mondja ki, hogy az ikerprímek reciprokértéke egy speciális konstanshoz tart, azaz konvergál. Ez a konstans az úgynevezett Brun-konstans vagy Brun szám, melynek 
            a pontos értékét csak becsülni tudjuk, de kb. 1.902160583104. De mik is azok az ikerprímek? Olyan prímszám párok, melyeknek különbsége pontosan 2, ilyen például a 3 és az 5 vagy a 11 és 13.
            Azt már Euklidesz bebizonyította, hogy a prím számok száma végtelen, viszont az még a mai napig kérdéses, hogy vajon a ikerprímek száma is végtelen-e. És akkor még nem is beszéltünk 
            a prímnégyesekről, ami megint csak egy különleges esett, ugyani azok olyan prímek ahol teljesűl, hogy ha n prím, akkor 10n+1, 10n+3, 10n+7, 10n+9 is prímek. Na de ne térjünk el a tárgytól. 
            Az ikerprímek helyzete azért is macerás, mert könnyű lenne rávágni, hogy ha a prímek végtelenek akkor az ikerprímek is, de ez nem  ilyen egyszerű, mert minél nagyobb értékeket vizsgálunk, annál 
            nagyobbak a prímek közti távolságok is (tehát egyre ritkábbak lesznek az ikrek). A kérdés hogy van-e vége és ebben talán segít kicsit a Brun tétel.   
        </para>
        <para>
            A következő példaprogramban 1.000.000 adjuk össze az ikrek reciprokját, majd végül egy koordináta rendszerben ábrázoljuk, hogy hogyan jut egyre közelebb az érték a Brun-konstanshoz. 
            Kezdjük is az elemzést. 
        </para>
        <programlisting language="R">
            <![CDATA[#   Copyright (C) 2019  Dr. Norbert Bátfai, nbatfai@gmail.com
            #
            #   This program is free software: you can redistribute it and/or modify
            #   it under the terms of the GNU General Public License as published by
            #   the Free Software Foundation, either version 3 of the License, or
            #   (at your option) any later version.
            #
            #   This program is distributed in the hope that it will be useful,
            #   but WITHOUT ANY WARRANTY; without even the implied warranty of
            #   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
            #   GNU General Public License for more details.
            #
            #   You should have received a copy of the GNU General Public License
            #   along with this program.  If not, see <http://www.gnu.org/licenses/>
            library(matlab)
            stp <- function(x){
                primes = primes(x)
                diff = primes[2:length(primes)]-primes[1:length(primes)-1]
                idx = which(diff==2)
                t1primes = primes[idx]
                t2primes = primes[idx]+2
                rt1plust2 = 1/t1primes+1/t2primes
                return(sum(rt1plust2))
            }
            x=seq(13, 1000000, by=10000)
            y=sapply(x, FUN = stp)
            plot(x,y,type="b")
            ]]>
            </programlisting>    
            <para>
                A program Bátfai Norbert munkája és R nyelven íródott. A Monty Hall Paradoxonos feladat is szintén R nyelvben készült, mely szakspeciális programozási nyelv. 
                Statisztikai kalkulációk és statisztikai ábrázolás során használják a leggyakrabban. 
                Daraboljuk fel picit:     
            </para>
            <programlisting language="R">
                <![CDATA[
                library(matlab)
                stp <- function(x){
                    primes = primes(x)
                    diff = primes[2:length(primes)]-primes[1:length(primes)-1]
                    idx = which(diff==2)
                    t1primes = primes[idx]
                    t2primes = primes[idx]+2
                    rt1plust2 = 1/t1primes+1/t2primes
                    return(sum(rt1plust2))
                }
                ]]>
            </programlisting> 
            <para>
                A licenceket most lecsíptem róla, azt nem részletezném. 
                Amivel kezdünk, az az hogy meghívjuk a matlab függvénykönyvtárat. Utána létrehozzuk az <function>stp</function> függvényt. 
            </para>
            <programlisting language="R">
                <![CDATA[
                    primes = primes(x)
                ]]>
            </programlisting> 
            <para>
                Elsőnek megkeressük a prímeket. 
            </para>
            <programlisting language="R">
                <![CDATA[
                diff = primes[2:length(primes)]-primes[1:length(primes)-1]
                idx = which(diff==2)
                ]]>
            </programlisting> 
            <para>
                Megnézzük az egymást követő prímek közti különbséget amit eltárolunk a <varname>diff</varname>-ben, ha ez kettő, az azt jelenti, hogy a két prím ikerprímet alkot és 
                eltároljuk az indexét az elsőnek, az <varname>idx</varname> változóba.  
            </para>
            <programlisting language="R">
                <![CDATA[
                t1primes = primes[idx]
                t2primes = primes[idx]+2
                ]]>
            </programlisting>
            <para>
                Az előző <varname>idx</varname> indexértékkel megállapítjuk a két prímet. 
            </para> 
            <programlisting language="R">
                <![CDATA[
                rt1plust2 = 1/t1primes+1/t2primes
                return(sum(rt1plust2))
                ]]>
            </programlisting>
            <para>
                A két prímnek a reciprokát összeadjuk, ez lesz a <varname>rt1plust2</varname>, majd a függvény visszatér ennek a szummájával. 
                Az <function>stp</function> ennyi volt, most pedig nézzük mi maradt még: 
            </para>
            <programlisting language="R">
                <![CDATA[
                x=seq(13, 1000000, by=10000)
                y=sapply(x, FUN = stp)
                plot(x,y,type="b")
                ]]>
            </programlisting>
            <para>
                Az <varname>x</varname>-be készítünk egy sorozatot 13-tól 1000000-ig a <function>seq()</function> függvénnyel. Az <varname>y</varname>-ban pedig összepárosítjuk az 
                <varname>x</varname>-et az <function>stp</function>-vel, azaz meghívjuk a függvényt. Majd végül de nem utolsósorban a <function>plot</function> segítségével ábrázoljuk a számításainkat.
                Ha minden jól ment akkor ezt kell kapnunk: 
            </para>
            <mediaobject>
                <imageobject>
                    <imagedata fileref="Pics/BrunKorok.png" scale="50" />
                </imageobject>
                <textobject>
                    <phrase>A B<subscript>2</subscript> konstans közelítése</phrase>
                </textobject>
            </mediaobject>
            <para>
                Gyönyörűen mutatja, hogy hogyan közelíti meg a Brun-konstanst. 
            </para>
        <!--
        <para>
            A természetes számok építőelemei a prímszámok. Abban az értelemben, 
            hogy minden természetes szám előállítható prímszámok szorzataként.
            Például 12=2*2*3, vagy például 33=3*11.
        </para>
        <para>
            Prímszám az a természetes szám, amely csak önmagával és eggyel 
            osztható. Eukleidész görög matematikus már Krisztus előtt tudta, 
            hogy végtelen sok prímszám van, de ma sem tudja senki, hogy 
            végtelen sok ikerprím van-e. Két prím ikerprím, ha különbségük 2.
        </para>
        <para>
            Két egymást követő páratlan prím között a legkisebb távolság a 2, 
            a legnagyobb távolság viszont bármilyen nagy lehet! Ez utóbbit 
            könnyű bebizonyítani. Legyen n egy tetszőlegesen nagy szám. 
            Akkor szorozzuk össze n+1-ig a számokat, azaz számoljuk ki az 
            1*2*3*… *(n-1)*n*(n+1) szorzatot, aminek a neve (n+1) faktoriális, 
            jele (n+1)!.
        </para>
        <para>
            Majd vizsgáljuk meg az a sorozatot:
        </para>    
        <para>
            (n+1)!+2, (n+1)!+3,… , (n+1)!+n, (n+1)!+ (n+1) ez n db egymást követő szám, ezekre (a jól ismert
            bizonyítás szerint) rendre igaz, hogy            
        </para>    
        <itemizedlist>
            <listitem>
                <para>(n+1)!+2=1*2*3*… *(n-1)*n*(n+1)+2, azaz 2*valamennyi+2, 2 többszöröse, így ami osztható kettővel</para>
            </listitem>
            <listitem>
                <para>(n+1)!+3=1*2*3*… *(n-1)*n*(n+1)+3, azaz 3*valamennyi+3, ami osztható hárommal</para>
            </listitem>
            <listitem>
                <para>...</para>
            </listitem>
            <listitem>
                <para>(n+1)!+(n-1)=1*2*3*… *(n-1)*n*(n+1)+(n-1), azaz (n-1)*valamennyi+(n-1), ami osztható (n-1)-el</para>
            </listitem>
            <listitem>
                <para>(n+1)!+n=1*2*3*… *(n-1)*n*(n+1)+n, azaz n*valamennyi+n-, ami osztható n-el</para>
            </listitem>
            <listitem>
                <para>(n+1)!+(n+1)=1*2*3*… *(n-1)*n*(n+1)+(n-1), azaz (n+1)*valamennyi+(n+1), ami osztható (n+1)-el</para>
            </listitem>
        </itemizedlist>
        <para>
            tehát ebben a sorozatban egy prim nincs, akkor a (n+1)!+2-nél 
            kisebb első prim és a (n+1)!+ (n+1)-nél nagyobb első 
            prim között a távolság legalább n.            
        </para>    
        <para>
            Az ikerprímszám sejtés azzal foglalkozik, amikor a prímek közötti 
            távolság 2. Azt mondja, hogy az egymástól 2 távolságra lévő prímek
            végtelen sokan vannak.
        </para>    
        <para>
            A Brun tétel azt mondja, hogy az ikerprímszámok reciprokaiból képzett sor összege, azaz
            a (1/3+1/5)+ (1/5+1/7)+ (1/11+1/13)+... véges vagy végtelen sor konvergens, ami azt jelenti, hogy ezek
            a törtek összeadva egy határt adnak ki pontosan vagy azt át nem lépve növekednek, 
            ami határ számot B<subscript>2</subscript> Brun konstansnak neveznek. Tehát ez
            nem dönti el a több ezer éve nyitott kérdést, hogy az ikerprímszámok halmaza végtelen-e? 
            Hiszen ha véges sok van és ezek
            reciprokait összeadjuk, akkor ugyanúgy nem lépjük át a B<subscript>2</subscript> Brun konstans értékét, 
            mintha végtelen 
            sok lenne, de ezek már csak olyan csökkenő mértékben járulnának hozzá a végtelen sor összegéhez, 
            hogy így sem lépnék át a Brun konstans értékét.     
        </para>
        <para>
            Ebben a példában egy olyan programot készítettünk, amely közelíteni próbálja a Brun konstans értékét.
            A repó <link xlink:href="../../../bhax/attention_raising/Primek_R/stp.r">
                <filename>bhax/attention_raising/Primek_R/stp.r</filename>
            </link> mevű állománya kiszámolja az ikerprímeket, összegzi
            a reciprokaikat és vizualizálja a kapott részeredményt.
        </para>
        <programlisting language="R">
<![CDATA[#   Copyright (C) 2019  Dr. Norbert Bátfai, nbatfai@gmail.com
#
#   This program is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with this program.  If not, see <http://www.gnu.org/licenses/>
library(matlab)
stp <- function(x){
    primes = primes(x)
    diff = primes[2:length(primes)]-primes[1:length(primes)-1]
    idx = which(diff==2)
    t1primes = primes[idx]
    t2primes = primes[idx]+2
    rt1plust2 = 1/t1primes+1/t2primes
    return(sum(rt1plust2))
}
x=seq(13, 1000000, by=10000)
y=sapply(x, FUN = stp)
plot(x,y,type="b")
]]>
        </programlisting>        
        <para>
            Soronként értelemezzük ezt a programot:
        </para>                
        <programlisting language="R">
<![CDATA[ primes = primes(13)]]>
        </programlisting>        
        <para>
            Kiszámolja a megadott számig a prímeket.             
        </para>
        <screen>
<![CDATA[> primes=primes(13)
> primes
[1]  2  3  5  7 11 13
]]>
        </screen>
                
        <programlisting language="R">
<![CDATA[ diff = primes[2:length(primes)]-primes[1:length(primes)-1]]]>
        </programlisting>        
        <screen>
<![CDATA[> diff = primes[2:length(primes)]-primes[1:length(primes)-1]
> diff
[1] 1 2 2 4 2
]]>
        </screen>        
        <para>
            Az egymást követő prímek különbségét képzi, tehát 3-2, 5-3, 7-5, 11-7, 13-11.
        </para>
        <programlisting language="R">
<![CDATA[idx = which(diff==2)]]>
        </programlisting>        
        <screen>
<![CDATA[> idx = which(diff==2)
> idx
[1] 2 3 5
]]>
        </screen>              
        <para>
            Megnézi a <varname>diff</varname>-ben, hogy melyiknél lett kettő az eredmény, mert azok az ikerprím párok, ahol ez igaz.
            Ez a <varname>diff</varname>-ben lévő 3-2, 5-3, 7-5, 11-7, 13-11 külünbségek közül ez a 2., 3. és 5. indexűre teljesül.
        </para>
        <programlisting language="R">
<![CDATA[t1primes = primes[idx]]]>
        </programlisting>  
        <para>
            Kivette a primes-ból a párok első tagját. 
        </para>
        <programlisting language="R">
<![CDATA[t2primes = primes[idx]+2]]>
        </programlisting>        
        <para>
            A párok második tagját az első tagok kettő hozzáadásával képezzük.
        </para>
        <programlisting language="R">
<![CDATA[rt1plust2 = 1/t1primes+1/t2primes]]>
        </programlisting>        
        <para>
            Az 1/t1primes a t1primes 3,5,11 értékéből az alábbi reciprokokat képzi:
        </para>
        <screen>
<![CDATA[> 1/t1primes
[1] 0.33333333 0.20000000 0.09090909
]]>
        </screen>                      
        <para>
            Az 1/t2primes a t2primes 5,7,13 értékéből az alábbi reciprokokat képzi:
        </para>
        <screen>
<![CDATA[> 1/t2primes
[1] 0.20000000 0.14285714 0.07692308
]]>
        </screen>                      
        <para>
            Az 1/t1primes + 1/t2primes pedig ezeket a törteket rendre összeadja.
        </para>
        <screen>
<![CDATA[> 1/t1primes+1/t2primes
[1] 0.5333333 0.3428571 0.1678322
]]>
        </screen>                      
        <para>
            Nincs más dolgunk, mint ezeket a törteket összeadni a 
            <function>sum</function> függvénnyel.
        </para>
        
        <programlisting language="R">
<![CDATA[sum(rt1plust2)]]>
        </programlisting>    
        <screen>
<![CDATA[>   sum(rt1plust2)
[1] 1.044023
]]>
        </screen>            
        <para>
            A következő ábra azt mutatja, hogy a szumma értéke, hogyan nő, egy határértékhez tart, a 
            B<subscript>2</subscript> Brun konstanshoz. Ezt ezzel a csipettel rajzoltuk ki, ahol először a fenti 
            számítást 13-ig végezzük, majd 10013, majd 20013-ig, egészen 990013-ig, azaz közel 1 millióig.
            Vegyük észre, hogy az ábra első köre, a 13 értékhez tartozó 1.044023.
        </para>
        <programlisting language="R">
<![CDATA[x=seq(13, 1000000, by=10000)
y=sapply(x, FUN = stp)
plot(x,y,type="b")]]>
        </programlisting>          
        <figure>
            <title>A B<subscript>2</subscript> konstans közelítése</title>
            <mediaobject>
                <imageobject>
                    <imagedata fileref="img/BrunKorok.png" scale="50" />
                </imageobject>
                <textobject>
                    <phrase>A B<subscript>2</subscript> konstans közelítése</phrase>
                </textobject>
            </mediaobject>
        </figure>
        <para>
            Ezek után érdemes lehet felvetni a kérdést, hogy ha az ikerprímek (p; p+2) reciprokainak összege
            a B<subscript>2</subscript> konstans konvergálnak, akkor vajon a prímnégyesek (p; p+2; p+6; p+8) reciprokai is konvergálnak-e
            valahova? 
        </para> 
    -->

        <tip>
            <title>Werkfilm</title>
            <itemizedlist>
                <listitem>
                    <para>
                        <link xlink:href="https://youtu.be/VkMFrgBhN1g">https://youtu.be/VkMFrgBhN1g</link>
                    </para>    
                </listitem>                
                <listitem>
                    <para>
                        <link xlink:href="https://youtu.be/aF4YK6mBwf4">https://youtu.be/aF4YK6mBwf4</link>
                    </para>    
                </listitem>                
            </itemizedlist>                
        </tip>
    </section>
    <section>
        <title>Malmo - Csiga</title>
        <para>
            Ez volt az első önálló feladatunk a Minecraft Malmo platformon. Ezen még nagy érződnek a kezdetleges szárnypróbálgatások. 
            Új volt mind a malmo, mind a python mindkettőnknek (Tutor Tünde), de mondhatom, hogy hamar megszerettük mindkettőt. 
            Ebben a feladatban Stevenek még nagyon egyszerű dolga van: Csiga mozgásban kell feljebb és feljebb jutnia a RedFlowerHell arénában 
            miközben fentről vészesen közeledik a láva.  
        </para>
        <para>
            Többféle képpen is próbáltuk megközelíteni a problémát, az alap koncepciónk az az volt, hogy egy dupla for ciklus 
            segítségével döntse el, hogy mikor mennyit menjen és hogy mikor forduljon. Ezt végül is elvetettük, mert nem volt túl átgondolt 
            és inkább újragondoltuk. Nyílván ezek a megoldások röhejesnek tűnhetnek, de még az alap szintaktikáját tanultuk a nyelvnek 
            és a környezetnek. 
        </para>
        <para>
            Nyílván a második nekifutás se tökéletes, sok sebből vérzik és visszanézve már azt mondhatjuk, hogy nagyon kezdetleges a 
            mostani kódjainkhoz (hálisten, hiszen ezek szerint tanultunk belőle). Itt az alap koncepció az volt, hogy Steve meghatározott ideig megy előre 
            ezáltal előbb vagy utóbb elérve a szakasz végét. Akkor fordul egyet és növeli a <varname>tmp</varname> nevű változót. Ha ez a 
            <varname>tmp</varname> eléri a 4-et az azt jelenti, hogy Steve körbeért, tehát mehet egyel feljebb.  
        </para>
        <para>
            Kőkorszaki megoldás, de ismerkedésnek jó volt. 
        </para>
        <para>Python: </para>
        <programlisting language="python">
            <![CDATA[ from __future__ import print_function
            # ------------------------------------------------------------------------------------------------
            # Copyright (c) 2016 Microsoft Corporation
            # 
            # Permission is hereby granted, free of charge, to any person obtaining a copy of this software and
            # associated documentation files (the "Software"), to deal in the Software without restriction,
            # including without limitation the rights to use, copy, modify, merge, publish, distribute,
            # sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is
            # furnished to do so, subject to the following conditions:
            # 
            # The above copyright notice and this permission notice shall be included in all copies or
            # substantial portions of the Software.
            # 
            # THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT
            # NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
            # NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
            # DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
            # OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
            # ------------------------------------------------------------------------------------------------
            
            # Tutorial sample #2: Run simple mission using raw XML
            
            # Added modifications by Norbert Bátfai (nb4tf4i) batfai.norbert@inf.unideb.hu, mine.ly/nb4tf4i.1
            # 2018.10.18, https://bhaxor.blog.hu/2018/10/18/malmo_minecraft
            # 2020.02.02, NB4tf4i's Red Flowers, http://smartcity.inf.unideb.hu/~norbi/NB4tf4iRedFlowerHell
            
            
            from builtins import range
            import MalmoPython
            import os
            import sys
            import time
            import random
            import json
            import math
            
            if sys.version_info[0] == 2:
                sys.stdout = os.fdopen(sys.stdout.fileno(), 'w', 0)  # flush print output immediately
            else:
                import functools
                print = functools.partial(print, flush=True)
            
            # Create default Malmo objects:
            
            agent_host = MalmoPython.AgentHost()
            try:
                agent_host.parse( sys.argv )
            except RuntimeError as e:
                print('ERROR:',e)
                print(agent_host.getUsage())
                exit(1)
            if agent_host.receivedArgument("help"):
                print(agent_host.getUsage())
                exit(0)
            
            # -- set up the mission -- #
            missionXML_file='nb4tf4i.xml'
            with open(missionXML_file, 'r') as f:
                print("NB4tf4i's Red Flowers (Red Flower Hell) - DEAC-Hackers Battle Royale Arena\n")
                print("NB4tf4i vörös pipacsai (Vörös Pipacs Pokol) - DEAC-Hackers Battle Royale Arena\n\n")
                print("The aim of this first challenge, called nb4tf4i's red flowers, is to collect as many red flowers as possible before the lava flows down the hillside.\n")
                print("Ennek az első, az nb4tf4i vörös virágai nevű kihívásnak a célja összegyűjteni annyi piros virágot, amennyit csak lehet, mielőtt a láva lefolyik a hegyoldalon.\n")    
                print("Norbert Bátfai, batfai.norbert@inf.unideb.hu, https://arato.inf.unideb.hu/batfai.norbert/\n\n")    
                print("Loading mission from %s" % missionXML_file)
                mission_xml = f.read()
                my_mission = MalmoPython.MissionSpec(mission_xml, True)
                my_mission.drawBlock( 0, 0, 0, "lava")
            
            
            class Hourglass:
                def __init__(self, charSet):
                    self.charSet = charSet
                    self.index = 0
                    #self.pitch = 0 #ide tettem a pitch miatt
                def cursor(self):
                    self.index=(self.index+1)%len(self.charSet)
                    return self.charSet[self.index]
            
            hg = Hourglass('|/-\|')
            
            class Steve:
                def __init__(self, agent_host):
                    self.agent_host = agent_host
                    self.x = 0
                    self.y = 0
                    self.z = 0        
                    self.yaw = 0
                    self.pitch = 0   
                    self.lookingat = 0
                    self.nof_red_flower = 0
            
                def run(self):
                    world_state = self.agent_host.getWorldState()
                    i = 2
                    j = 1
                    tmp = 1
                    #Loop until mission ends:
                    while world_state.is_mission_running:
                        print("--- nb4tf4i arena -----------------------------------\n")
            
                        if world_state.number_of_observations_since_last_state != 0:
                            
                            sensations = world_state.observations[-1].text
                            print("    sensations: ", sensations)                
                            observations = json.loads(sensations)
                            nbr3x3x3 = observations.get("nbr3x3", 0)
                            print("    3x3x3 neighborhood of Steve: ", nbr3x3x3)
                            
                            if "Yaw" in observations:
                                self.yaw = int(observations["Yaw"])
                            if "Pitch" in observations:
                                self.pitch = int(observations["Pitch"])
                            if "XPos" in observations:
                                self.x = int(observations["XPos"])
                            if "ZPos" in observations:
                                self.z = int(observations["ZPos"])        
                            if "YPos" in observations:
                                self.y = int(observations["YPos"])  
                            
                            print("    Steve's Coords: ", self.x, self.y, self.z)        
                            print("    Steve's Yaw: ", self.yaw)        
                            print("    Steve's Pitch: ", self.pitch)
            
                            if "LineOfSight" in observations:
                                LineOfSight = observations["LineOfSight"]
                                self.lookingat = LineOfSight["type"]
                            print("    Steve's <): ", self.lookingat)
                            """
                            if self.lookingat == "red_flower":
                                print("    viraaag!!4!!negy!!")
                                self.agent_host.sendCommand("move 1")
            
                            if "Pitch" in observations:
                                self.pitch = int(observations["Pitch"])
            
                            self.agent_host.sendCommand( "Pitch .3" )
                            time.sleep(.5)
                            if self.lookingat == "dirt":
                                print("FOOOLD!!!")
                            """
            
                                #Mozgás    
            
                            self.agent_host.sendCommand( "move 1" )
                            time.sleep(1.2*i)
                            self.agent_host.sendCommand( "move 0" )
                            time.sleep(.5)
                            if tmp == 4:
                                tmp = 0
                                self.agent_host.sendCommand( "jump 1" )
                                time.sleep(.5)
                                self.agent_host.sendCommand( "move 1" )
                                time.sleep(.5)
                                self.agent_host.sendCommand( "jump 0" )
                                time.sleep(.5)
                                self.agent_host.sendCommand( "move 0" )
                                time.sleep(.5)             
                            self.agent_host.sendCommand( "turn 1" )
                            time.sleep(.5)
                            self.agent_host.sendCommand( "turn 0" )
                            time.sleep(.5)
                            tmp = tmp + 1
                            i = i + 1
                                
            
                        world_state = self.agent_host.getWorldState()
                                    
                          
                        
                        """
                        for i in range(64):
                                for j in range(4):
                                    self.agent_host.sendCommand( "move 1" )
                                    time.sleep(1.7*i)
                                    self.agent_host.sendCommand( "move 0" )
                                    time.sleep(.5)             
                                    self.agent_host.sendCommand( "turn 1" )
                                    time.sleep(.5)
                                    self.agent_host.sendCommand( "turn 0" )
                                    time.sleep(.5)
                                self.agent_host.sendCommand( "jump 1" )
                                time.sleep(.5)
                                self.agent_host.sendCommand( "move 1" )
                                time.sleep(.5)
                                self.agent_host.sendCommand( "jump 0" )
                                time.sleep(.5)
                        """
            
                        #for i in range(64):
                            #ide tettem a pitch miatt
            
            num_repeats = 1
            for ii in range(num_repeats):
            
                my_mission_record = MalmoPython.MissionRecordSpec()
            
                # Attempt to start a mission:
                max_retries = 6
                for retry in range(max_retries):
                    try:
                        agent_host.startMission( my_mission, my_mission_record )
                        break
                    except RuntimeError as e:
                        if retry == max_retries - 1:
                            print("Error starting mission:", e)
                            exit(1)
                        else:
                            print("Attempting to start the mission:")
                            time.sleep(2)
            
                # Loop until mission starts:
                print("   Waiting for the mission to start ")
                world_state = agent_host.getWorldState()
            
                while not world_state.has_mission_begun:
                    print("\r"+hg.cursor(), end="")
                    time.sleep(0.15)
                    world_state = agent_host.getWorldState()
                    for error in world_state.errors:
                        print("Error:",error.text)
            
                print("NB4tf4i Red Flower Hell running\n")
                steve = Steve(agent_host)
                steve.run()
                print("Number of flowers: "+ str(steve.nof_red_flower))
            
            print("Mission ended")
            # Mission has ended.
            ]]>
        </programlisting>
    </section>
   
</chapter>         