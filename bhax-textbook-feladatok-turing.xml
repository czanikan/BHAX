<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <info>
        <title>Helló, Turing!</title>
        <keywordset>
            <keyword/>
        </keywordset>
    </info>
    <section>
        <title>1. Feladat: Végtelen ciklusok </title>
        <para>
            Egy mag kihasználása 100%-on:

            Két megoldás is készült a probléma feloldására. 
            A két általános végtelen ciklus ("while(true); és for(;;);") 
            <!--endlessWhile.c és endlessFor.c-->
            felhasználásával, de ezeket tekinthetjük akár csak egy féle ciklusként is,
            hiszen ha átfordítjuk őket assembly-re, akkor a két forráskódunk, 
            a nevén kívűl mindenben megegyezik.
            <!--endlessWhile.s és endlessFor.s--> 
            Na de miért használja ki egy mag százszázalékát?
            A válasz egyszerű. Azért mert egy mag egyszerre egy feladatot, tud ellátni, 
            de a feladatok közt nagyon gyorsan tud váltani. Viszont, ha egy végtelen ciklust
            kap szerencsétlen, akkor kénytelen annak feltételét folyamatosan ellenőrizni, így 
            nincs lehetősége, hogy váltson más feladatra vagy pihenjen.
            <!--screenshot: htop onecore100% -->
        </para>
        <para>
            Egy mag 0%-on:

            Hasonlóan indulunk el mint az előző esetén. Itt is megírjuk a kis végtelen ciklusunkat,
            viszont annyit módosítunk rajta, hogy adunk egy kis extra feladatot a processzornak 
            azon túl, hogy a feltételt ellenőrizgesse. 
            <!--endlessWhileSleep.c-->
            Ez lehet elsőre furcsán hangzik, de ha kap egy
            feladatott, ami méghozzá egy szüneteltetés ("sleep(1)") mégha csak egy nagyon kicsi 
            időintervallumig is, de van lehetősége megpihenni, ami a processzor magnak bőven elég is lesz.
            Ezért látjuk azt, hogy közel/teljesen 0%-on fut a mag.
            <!--screenshot: htop onecore0% -->
        </para>
        <para>
            Az összes mag 100%-on:

            Ha már játszunk a magokkal, akkor játszunk rendesen. All in!
            <!--endlessForAllCores.c-->
            Kicsit kiegészítjük a végtelen for ciklusunkat. Az első, hogy meghívjuk a megfelelő
            könyvtárat, ami jelen esetben az 'omp.h'. Erre azért lesz szükségünk, hogy parallax 
            programmá alakíthassuk a programunkat. A parallax programok lényege, minden minőségi 
            kifejtési igény nélkül, hogy kihasználja az összes erőforrást futtatáskor.
            Pontosan, ez kapóra is jön nekünk, mert ha már egy magot tudunk pörgetni maxon, akkor 
            így az összeset tudjuk majd. És láss csodát, valóban!
            <!--screenshot: htop allcores100%-->
        </para>
        <para>
            A legnagyobb tanulság amit levonhatunk ebből a rövid kisértleből, az nem más, mint hogy 
            a végtelen ciklusok ugyan hasznosak, de kilépési feltétel és megszakítás nélkül, rendesen
            el tudják foglalni a processzor magokat. Ami csak azért lehet problémás, mert akkor váltani
            se tudnak a feladatok között, amiből mi csak annyit érzékelünk, hogy gépünk nem végzi el a feladatát,
            sőt semmit se csinál, azaz lefagy.
            Ha lehet kerüljétek, de ha mindenképp kell, akkor is legyen benne feltétel a megszakításra.
        </para>
        <para>
            Megoldás videó: <link xlink:href="https://youtu.be/ittlesz">https://youtu.be/ittlesz</link>
        </para>
        <para>
            Megoldás forrása: <link xlink:href="Turing/infty-f.c">
                <filename>bhax/thematic_tutorials/bhax_textbook_IgyNeveldaProgramozod/Turing/infty-f.c</filename>
            </link>, 
            <link xlink:href="Turing/infty-w.c">
                <filename>bhax/thematic_tutorials/bhax_textbook_IgyNeveldaProgramozod/Turing/infty-w.c</filename>
            </link>.
        </para>
        <programlisting language="c"><![CDATA[int
main ()
{
  for (;;);

  return 0;
}
]]>
        </programlisting>        
        <para>        
        vagy az olvashatóbb, de a programozók és fordítók (szabványok) között kevésbé hordozható
        </para>
        <programlisting language="c"><![CDATA[int
#include <stdbool.h>
main ()
{
  while(true);

  return 0;
}
]]>
        </programlisting>                   
        <screen><![CDATA[$ gcc -S -o infty-f.S infty-f.c 
$ gcc -S -o infty-w.S infty-w.c 
$ diff infty-w.S infty-f.S 
1c1
< 	.file	"infty-w.c"
---
> 	.file	"infty-f.c"
]]></screen>  
        <para>
            Egy mag 0 százalékban:               
        </para>        
        <programlisting language="c"><![CDATA[#include <unistd.h>
int
main ()
{
  for (;;)
    sleep(1);
    
  return 0;
}
]]>
        </programlisting>        
        <para>
            Minden mag 100 százalékban:               
        </para>

        <programlisting language="c"><![CDATA[#include <omp.h>
int
main ()
{
#pragma omp parallel
{
  for (;;);
}
  return 0;
}
]]>
        </programlisting>        
        <para>
            A <command>gcc infty-f.c -o infty-f -fopenmp</command> parancssorral készítve a futtathatót, majd futtatva,               
            közben egy másik terminálban a <command>top</command> parancsot kiadva tanulmányozzuk, mennyi CPU-t használunk:            
        </para>
        <screen><![CDATA[top - 20:09:06 up  3:35,  1 user,  load average: 5,68, 2,91, 1,38
Tasks: 329 total,   2 running, 256 sleeping,   0 stopped,   1 zombie
%Cpu0 :100,0 us, 0,0 sy, 0,0 ni, 0,0 id, 0,0 wa, 0,0 hi, 0,0 si, 0,0 st
%Cpu1 : 99,7 us, 0,3 sy, 0,0 ni, 0,0 id, 0,0 wa, 0,0 hi, 0,0 si, 0,0 st
%Cpu2 :100,0 us, 0,0 sy, 0,0 ni, 0,0 id, 0,0 wa, 0,0 hi, 0,0 si, 0,0 st
%Cpu3 : 99,7 us, 0,3 sy, 0,0 ni, 0,0 id, 0,0 wa, 0,0 hi, 0,0 si, 0,0 st
%Cpu4 :100,0 us, 0,0 sy, 0,0 ni, 0,0 id, 0,0 wa, 0,0 hi, 0,0 si, 0,0 st
%Cpu5 :100,0 us, 0,0 sy, 0,0 ni, 0,0 id, 0,0 wa, 0,0 hi, 0,0 si, 0,0 st
%Cpu6 :100,0 us, 0,0 sy, 0,0 ni, 0,0 id, 0,0 wa, 0,0 hi, 0,0 si, 0,0 st
%Cpu7 :100,0 us, 0,0 sy, 0,0 ni, 0,0 id, 0,0 wa, 0,0 hi, 0,0 si, 0,0 st
KiB Mem :16373532 total,11701240 free, 2254256 used, 2418036 buff/cache
KiB Swap:16724988 total,16724988 free,       0 used. 13751608 avail Mem 

  PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND     
 5850 batfai    20   0   68360    932    836 R 798,3  0,0   8:14.23 infty-f     
]]></screen>  

    </section>        
        
    <section>
        <title>2. Feladat: Lefagyott, nem fagyott, akkor most mi van?</title>
        <para>
            Megoldás forrása:  tegyük fel, hogy akkora haxorok vagyunk, hogy meg tudjuk írni a <function>Lefagy</function>
            függvényt, amely tetszőleges programról el tudja dönteni, hogy van-e benne vlgtelen ciklus:              
        </para>
        <programlisting language="c"><![CDATA[Program T100
{

	boolean Lefagy(Program P)
	{
		 if(P-ben van végtelen ciklus)
			return true;
		 else
			return false; 
	}

	main(Input Q)
	{
		Lefagy(Q)
	}
}]]></programlisting>            
        <para>
            A program futtatása, például akár az előző <filename>v.c</filename> ilyen pszeudókódjára:
            <screen><![CDATA[T100(t.c.pseudo)
true]]></screen>            
            akár önmagára
            <screen><![CDATA[T100(T100)
false]]></screen>  
            ezt a kimenetet adja.          
        </para>
        <para>
            A T100-as programot felhasználva készítsük most el az alábbi T1000-set, amelyben a
            Lefagy-ra épőlő Lefagy2 már nem tartalmaz feltételezett, csak csak konkrét kódot:
        </para>
        <programlisting language="c"><![CDATA[Program T1000
{

	boolean Lefagy(Program P)
	{
		 if(P-ben van végtelen ciklus)
			return true;
		 else
			return false; 
	}

	boolean Lefagy2(Program P)
	{
		 if(Lefagy(P))
			return true;
		 else
			for(;;); 
	}

	main(Input Q)
	{
		Lefagy2(Q)
	}

}]]></programlisting>            
        <programlisting><![CDATA[]]></programlisting>            
        <para>
            Mit for kiírni erre a <computeroutput>T1000(T1000)</computeroutput> futtatásra?
                                
            <itemizedlist>
                <listitem>
                    <para>Ha T1000 lefagyó, akkor nem fog lefagyni, kiírja, hogy true</para>                        
                </listitem>
                <listitem>
                    <para>Ha T1000 nem fagyó, akkor pedig le fog fagyni...</para>                        
                </listitem>
            </itemizedlist>
            akkor most hogy fog működni? Sehogy, mert ilyen <function>Lefagy</function>
            függvényt, azaz a T100 program nem is létezik.                
        </para>
        <para>
            A fő probléma abban rejlik, hogy az if-else ágban egy ellentmondásba ütközünk. Mivel ha a P programban van 
            végtelen ciklus, akkor a <function>Lefagy2</function> egy true értékkel, ellenben ha meg nincs benne, akkor
            visszatérne egy további for ciklussal, hogy tovább figyeljen, ami viszont ahhoz vezet, hogy akkor már lesz benne
            végtelen ciklus. Tehát ha nem fagyott le eddig, akkor mostmár le fog.
        </para>
        <para>
            Szerencsére sok modern IDE-ban van olyan kisegítő lehetőség, mely figyelmeztet minket arra, ha programunk olyan
            végtelen ciklust tartalmaz, melynek nincs kilépési feltétele. Ez sokat segíthet, de még így is könnyen megtörténhet
            hogy figyelmetlenség miatt benne marad. És mivel ez csak egy figyelmeztetés és nem hibaüzenet, ezért a program 
            fordítható és futtatható, így lehet jó ideig elő se jön a probléma.
        </para>
    </section>        
                
    <section>
        <title>3. Feladat: Változók értékének felcserélése</title>
        <para>
            Az alábbi programban három általános módját tekinthejük meg a változók közti értékcserének.
            A használat könnyítése érdekében, ez tartalmaz egy <command>switch</command> utasítást, hogy könnyen
            kiválaszthassuk, hogy melyik módszert szeretnénk alkalmazni
        </para>
        <para>
            <programlisting language="c"><![CDATA[#include <stdio.h>
                #include <stdlib.h>
                int main()
                {
                    int a = 0;
                    int b = 0;
                    int tmp = 0;
                    int choice;
                    while(1)
                    {
                        printf("a = ");
                        scanf("%d",&a);
                        printf("\nb = ");
                        scanf("%d",&b);
                        printf("\n---x{[MENU]}x---\n");
                        printf("1 - Seged valtozoval\n");
                        printf("2 - Kivonassal\n");
                        printf("3 - Osszeadassal\n");
                        printf("9 - Exit\n");
                        fflush(stdin);
                        scanf("%d",&choice);
                
                        switch(choice)
                        {
                            case 1:
                                tmp = a;
                                a = b;
                                b = tmp;
                                printf("a = %d, b = %d\n", a, b);
                                break;
                
                            case 2:
                                a = a - b;
                                b = a + b;
                                a = b - a;
                                printf("a = %d, b = %d\n", a, b);
                                break;
                
                            case 3:
                                a = a + b;
                                b = a - b;
                                a = a - b;
                                printf("a = %d, b = %d\n", a, b);
                                break;
                
                            case 9:
                                break;
                            default:
                                printf("Invalid bemenet!\n");
                        }
                        break;
                    }
                    return 0;
                }]]></programlisting>
        </para>
        <para>
            A segédváltós értékcserét egy egyszerű példával szemléltetném: Van az asztalon egy pohár almalé és egy 
            pohár narancslé és szeretnénk a két pohár tartalmát felcserélni. Ez a feladat így nem más mint egy 
            gordiuszi csomó. De mielőtt pánikba esünk, hívjunk segítségül egy harmadik, de üres poharat. Ez a pohár lesz
            a segédváltozónk, vagy jelen esetben segédpoharunk. Ha a segédpohárba átöntjük az almalevet, akkor az a pohár üres lesz,
            így abba átönthetjük a narancslevet. Ami által a narancsleves pohár is felszabadúl. Ezután a segédpohárból beleönthetjük
            az almalevet az immár üres pohárba. Egyszerű, nem igaz?
        </para>
    </section>                     

    <section>
        <title>4. Feladat: Labdapattogás</title>
        <para>
            Először if-ekkel, majd bármiféle logikai utasítás vagy kifejezés
            nasználata nélkül írj egy olyan programot, ami egy labdát pattogtat a karakteres konzolon! (Hogy mit értek
            pattogtatás alatt, alább láthatod a videókon.)
        </para>
        <para>
            Megoldás forrása:
            <programlisting language="c"><![CDATA[#include <stdio.h>
                #include <curses.h>
                #include <unistd.h>
                int main()
                {
                    WINDOW *ablak;
                    ablak = initscr();

                    int x = 0;
                    int y = 0;

                    int delX = 1;
                    int delY = 1;

                    int mx;
                    int my;
                    
                    while(true)
                    {
                        printf("\033[0;32m");

                        getmaxyx(ablak, my, mx);
                        mvprintw(y, x, "(DVD)");

                        refresh();
                        usleep(100000);
                        
                        clear();

                        x = x + delX;
                        y = y + delY;
                        /*
                        if(x <= 0)
                        {
                            delX = delX * -1;
                            //printf("\033[0;31m");
                        }
                        if(x >= mx-1)
                        {
                            delX = delX * -1;
                            //printf("\033[0;32m");
                        }
                        if(y <= 0)
                        {
                            delY = delY * -1;
                            //printf("\033[0;33m");
                        }
                        if(y >= my-1)
                        {
                            delY = delY * -1;
                            //printf("\033[0;34m");
                        }
                        */
                        for(;x <= 0;)
                        {
                            delX = delX * -1;
                            break;
                        }
                        for(;x >= mx-1;)
                        {
                            delX = delX * -1;
                            break;
                        }
                        for(;y <= 0;)
                        {
                            delY = delY * -1;
                            break;
                        }
                        for(;y >= my-1;)
                        {
                            delY = delY * -1;
                            break;
                        }
                    }

                    return 0;
                }]]></programlisting>  
        </para>
        <para>
            Eleve az adott példa alapján megírtam a program if-es változatát, mely kommentként szerepel a forrásban.
            Ezután az if nélküli verzióban az if-ek feladatát kiszerveztem for ciklusoknak, melyek csak akkor lépnek életbe, ha a 
            '(DVD)' karakter eléri az ablak valamelyik szélét, majd ez alapján x vagy y értékét negatív előjelüvé cseréljük, azaz 
            visszapattinjuk a falról. Kicsit hasonlít a technika arra mint amit az Atari Blockbreaker játékában is alkalmaztak, hogy
            visszapattanjon a labda a játékosról, azzal a kis extrával, hogy ott vektorokat alkalmaztak, így a vektor hossz alapján
            lehetet kicsit befolyásolni a visszapattanási szöget. Egyszerű megoldás, de így nem volt olyan statikus és kiszámítható
            a labda új íránya, ezzel változatosabbá téve a játékot.
            Mellesleg az én példámban 'o' helyett a '(DVD)' szerepel, mivel kisebb koromban szerettem nézni a DVD lejátszókon
            a képernyőkimélőt, melyen a felirat minden visszapattanás után színt váltott. Ezt egy kis "easteregg"-nek szántam.
        </para>
    </section>                     

    <section>
        <title>5. Feladat: Szóhossz és a Linus Torvalds féle BogoMIPS</title>
        <para>
            Írj egy programot, ami megnézi, hogy hány bites a szó a gépeden, azaz mekkora az <type>int</type> mérete.
            Használd ugyanazt a while ciklus fejet, amit Linus Torvalds a BogoMIPS rutinjában! 
        </para>
        <para>
            Megoldás videó: <link xlink:href="https://youtu.be/9KnMqrkj_kU">https://youtu.be/9KnMqrkj_kU</link>, 
            <link xlink:href="https://youtu.be/KRZlt1ZJ3qk">https://youtu.be/KRZlt1ZJ3qk</link>, 
            <link xlink:href=""></link>.
        </para>
        <para>
            Megoldás forrása: <link xlink:href="Turing/bogomips.c">
                <filename>bhax/thematic_tutorials/bhax_textbook_IgyNeveldaProgramozod/Turing/bogomips.c</filename>
            </link>
        </para>
        <para>
            A program lényege, hogy bináris eltolással végig lépkedjünk egy <type>long long</type> típusú változón,
            miközben mérjük, hogy mennyi ideig tart ez neki. Ezután a kapott hatalmas számot el kell osztanunk egy
            számmal (ez egy tetszőleges szám lehet, a cél csak az, hogy az eredmény 100-1000 között legyen).
            Ennek a számnak nincs mértékegysége, de ha összehasonlítjuk más gépek értékével, melyeken ugyan ezt a programot
            futtatjuk, akkor egyszerűen megállapítható, hogy melyik gép processzora számít gyorsabban.
        </para>
        <para>
            Ha a program <loop>while()</loop> ciklusa előtt létrehozunk egy változót és ennek értékét ciklus futásonként 
            növeljük, akkor visszakapjuk a <type>long long</type> típus méretét bitben.
        </para>
    </section>                     

    <section>
        <title>6. Feladat: Helló, Google!</title>
        <para>
            Írj olyan C programot, amely egy 4 honlapból álló hálózatra kiszámolja a négy lap Page-Rank 
            értékét!
        </para>
        <para>
            Megoldás videó: <link xlink:href=""></link>
        </para>
        <para>
            Megoldás forrása: <link xlink:href=""></link>
        </para>
        <para>
            <programlisting language="c"><![CDATA[#include <stdio.h>
                #include <stdlib.h>
                
                double distance (double PR[], double PRv[], int db)
                {
                    double dist = 0.0;
                    for(int i = 0; i < db; i++)
                    {
                        dist += abs(PR[i] - PRv[i]);
                    }
                    return dist;
                }
                
                void kiir (double list[], int db)
                {
                    for(int i = 0; i < db; i++)
                    {
                        printf("PageRank [%d]: %lf\n", i, list[i]);
                    }
                }
                
                int main(void)
                {
                    double L[4][4] = 
                    {
                    {0.0, 0.0, 1.0/3.0, 0.0},
                    {1.0, 1.0/2.0, 1.0/3.0, 1.0},
                    {0.0, 1.0/2.0, 0.0, 0.0},
                    {0.0, 0.0, 1.0/3.0, 0.0}
                    };
                
                    double PR[4] = {0.0, 0.0, 0.0, 0.0};
                    double PRv[4] = {1.0/4.0, 1.0/4.0, 1.0/4.0, 1.0/4.0};
                
                    for(;;)
                    {
                        for(int i = 0; i < 4; i++)
                        {
                            PR[i] = PRv[i];
                        }
                        for(int i = 0; i < 4; i++)
                        {
                            for(int j = 0; j < 4; j++)
                            {
                                PRv[i] += L[i][j] * PR[j];                
                            }
                        }
                        if(distance(PR, PRv, 4) < 0.00001)
                        {
                            break;
                        }
                    }
                    kiir (PR, 4);
                    return 0;
                }
                ]]></programlisting>
        </para>
        <para>
            A program lényege, hogy kicsiben (4 értéket használva) modellezzük a Google Page Rank algoritmusát.
        </para>
    </section>
                                                                                                                                                                                                                                                                                                                                                        
    <section xml:id="bhax-textbook-feladatok-turing.MontyHall">
        <title>A Monty Hall probléma</title>
        <para>
            Írj R szimulációt a Monty Hall problémára!
        </para>
        <para>
            Megoldás videó: <link xlink:href="https://bhaxor.blog.hu/2019/01/03/erdos_pal_mit_keresett_a_nagykonyvben_a_monty_hall-paradoxon_kapcsan">https://bhaxor.blog.hu/2019/01/03/erdos_pal_mit_keresett_a_nagykonyvben_a_monty_hall-paradoxon_kapcsan</link>
        </para>
        <para>
            Megoldás forrása: <link xlink:href="https://gitlab.com/nbatfai/bhax/tree/master/attention_raising/MontyHall_R">https://gitlab.com/nbatfai/bhax/tree/master/attention_raising/MontyHall_R</link>
        </para>
        <para>
            A Monty Hall paradoxon nevét a Monty Hall Show (és műsorvezetője akit meglepő mód szintén így hívtak) után 
            kapta. A probléma megértéséhez vázolnám röviden a műsor menetét:
            Adott volt három ajtó. Az egyik ajtó mögött egy méregdrága sportkocsi volt, míg a másik kettő mögött egy-egy
            kecske. A játékosnak nem volt más dolga mint megtippelnie, hogy melyik ajtó rejti a mesés fődíjat.
            Miután a játékos megtette a voksát, utánna Monty feltárta a maradék két ajtó közül az egyiket amelyik kecsét rejtett
            és lehetőséget adott a játékosnak az újraválasztásra.
            Na de joggal kérdezhetnénk, hogy hol ebben a paradoxon. A probléma ott kezdődött mikor előkerültek a műsor statisztikái,
            miszerint akik újra választottak ajtót, miután Monty felfedte az egyik ajtó titkát, azok majdnem kétszer olyan gyakran
            nyertek, mint akik nem.
        </para>
        <para>
            Amikor elsőnek választ ajtót a játékos, az egy egyszerű valószínűség számítási probléma, hiszen három ajtónk van,
            de csak egy fődíj, azaz minden ajtónak 1/3 esélye van, hogy az autót rejti. Lényegében mindegy melyik ajtót választja
            az ember. A probléma gyökere abból adódik, hogy mikor Monty választ egy ajtót ami mögött ő tudja, hogy kecske lesz és
            felkinálja az újraválasztás lehetőségét, a dolgok nem úgy folytatódnak ahogy az logikus lenne (legalábbis a statisztika szerint).
            Ugyebár logikusan azt gondolnánk, hogy maradt két ajtó, az egyik mögött még mindig ott a díj, mindkét ajtónak ugyan annyi esélye van
            (50%-50%), tehát felesleges lenne újat választani. Viszont ahogy azt az analitika mutatja, a dolgok nem így mennek, 
            hanem az ajtók esélyei, maradnak az eredetiek, viszont mikor Monty felfedi az egyik ajtót, akkor viszont annak az esélyei,
            átszállnak a megmaradt ajtóra, amivel jelentősen romlanak eredeti esélyeink (1/3:2/3).
        </para>
    </section>

    <section xml:id="Brun">
        <title>100 éves a Brun tétel</title>
        <para>
            Írj R szimulációt a Brun tétel demonstrálására!
        </para>
        <para>
            Megoldás videó: <link xlink:href="https://youtu.be/xbYhp9G6VqQ">https://youtu.be/xbYhp9G6VqQ</link>
        </para>
        <para>
            Megoldás forrása: <link xlink:href="https://gitlab.com/nbatfai/bhax/blob/master/attention_raising/Primek_R">https://gitlab.com/nbatfai/bhax/blob/master/attention_raising/Primek_R</link>
        </para>

        <para>
            A természetes számok építőelemei a prímszámok. Abban az értelemben, 
            hogy minden természetes szám előállítható prímszámok szorzataként.
            Például 12=2*2*3, vagy például 33=3*11.
        </para>
        <para>
            Prímszám az a természetes szám, amely csak önmagával és eggyel 
            osztható. Eukleidész görög matematikus már Krisztus előtt tudta, 
            hogy végtelen sok prímszám van, de ma sem tudja senki, hogy 
            végtelen sok ikerprím van-e. Két prím ikerprím, ha különbségük 2.
        </para>
        <para>
            Két egymást követő páratlan prím között a legkisebb távolság a 2, 
            a legnagyobb távolság viszont bármilyen nagy lehet! Ez utóbbit 
            könnyű bebizonyítani. Legyen n egy tetszőlegesen nagy szám. 
            Akkor szorozzuk össze n+1-ig a számokat, azaz számoljuk ki az 
            1*2*3*… *(n-1)*n*(n+1) szorzatot, aminek a neve (n+1) faktoriális, 
            jele (n+1)!.
        </para>
        <para>
            Majd vizsgáljuk meg az a sorozatot:
        </para>    
        <para>
            (n+1)!+2, (n+1)!+3,… , (n+1)!+n, (n+1)!+ (n+1) ez n db egymást követő szám, ezekre (a jól ismert
            bizonyítás szerint) rendre igaz, hogy            
        </para>    
        <itemizedlist>
            <listitem>
                <para>(n+1)!+2=1*2*3*… *(n-1)*n*(n+1)+2, azaz 2*valamennyi+2, 2 többszöröse, így ami osztható kettővel</para>
            </listitem>
            <listitem>
                <para>(n+1)!+3=1*2*3*… *(n-1)*n*(n+1)+3, azaz 3*valamennyi+3, ami osztható hárommal</para>
            </listitem>
            <listitem>
                <para>...</para>
            </listitem>
            <listitem>
                <para>(n+1)!+(n-1)=1*2*3*… *(n-1)*n*(n+1)+(n-1), azaz (n-1)*valamennyi+(n-1), ami osztható (n-1)-el</para>
            </listitem>
            <listitem>
                <para>(n+1)!+n=1*2*3*… *(n-1)*n*(n+1)+n, azaz n*valamennyi+n-, ami osztható n-el</para>
            </listitem>
            <listitem>
                <para>(n+1)!+(n+1)=1*2*3*… *(n-1)*n*(n+1)+(n-1), azaz (n+1)*valamennyi+(n+1), ami osztható (n+1)-el</para>
            </listitem>
        </itemizedlist>
        <para>
            tehát ebben a sorozatban egy prim nincs, akkor a (n+1)!+2-nél 
            kisebb első prim és a (n+1)!+ (n+1)-nél nagyobb első 
            prim között a távolság legalább n.            
        </para>    
        <para>
            Az ikerprímszám sejtés azzal foglalkozik, amikor a prímek közötti 
            távolság 2. Azt mondja, hogy az egymástól 2 távolságra lévő prímek
            végtelen sokan vannak.
        </para>    
        <para>
            A Brun tétel azt mondja, hogy az ikerprímszámok reciprokaiból képzett sor összege, azaz
            a (1/3+1/5)+ (1/5+1/7)+ (1/11+1/13)+... véges vagy végtelen sor konvergens, ami azt jelenti, hogy ezek
            a törtek összeadva egy határt adnak ki pontosan vagy azt át nem lépve növekednek, 
            ami határ számot B<subscript>2</subscript> Brun konstansnak neveznek. Tehát ez
            nem dönti el a több ezer éve nyitott kérdést, hogy az ikerprímszámok halmaza végtelen-e? 
            Hiszen ha véges sok van és ezek
            reciprokait összeadjuk, akkor ugyanúgy nem lépjük át a B<subscript>2</subscript> Brun konstans értékét, 
            mintha végtelen 
            sok lenne, de ezek már csak olyan csökkenő mértékben járulnának hozzá a végtelen sor összegéhez, 
            hogy így sem lépnék át a Brun konstans értékét.     
        </para>
        <para>
            Ebben a példában egy olyan programot készítettünk, amely közelíteni próbálja a Brun konstans értékét.
            A repó <link xlink:href="../../../bhax/attention_raising/Primek_R/stp.r">
                <filename>bhax/attention_raising/Primek_R/stp.r</filename>
            </link> mevű állománya kiszámolja az ikerprímeket, összegzi
            a reciprokaikat és vizualizálja a kapott részeredményt.
        </para>
        <programlisting language="R">
<![CDATA[#   Copyright (C) 2019  Dr. Norbert Bátfai, nbatfai@gmail.com
#
#   This program is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with this program.  If not, see <http://www.gnu.org/licenses/>

library(matlab)

stp <- function(x){

    primes = primes(x)
    diff = primes[2:length(primes)]-primes[1:length(primes)-1]
    idx = which(diff==2)
    t1primes = primes[idx]
    t2primes = primes[idx]+2
    rt1plust2 = 1/t1primes+1/t2primes
    return(sum(rt1plust2))
}

x=seq(13, 1000000, by=10000)
y=sapply(x, FUN = stp)
plot(x,y,type="b")
]]>
        </programlisting>        
        <para>
            Soronként értelemezzük ezt a programot:
        </para>                
        <programlisting language="R">
<![CDATA[ primes = primes(13)]]>
        </programlisting>        
        <para>
            Kiszámolja a megadott számig a prímeket.             
        </para>
        <screen>
<![CDATA[> primes=primes(13)
> primes
[1]  2  3  5  7 11 13
]]>
        </screen>
                
        <programlisting language="R">
<![CDATA[ diff = primes[2:length(primes)]-primes[1:length(primes)-1]]]>
        </programlisting>        
        <screen>
<![CDATA[> diff = primes[2:length(primes)]-primes[1:length(primes)-1]
> diff
[1] 1 2 2 4 2
]]>
        </screen>        
        <para>
            Az egymást követő prímek különbségét képzi, tehát 3-2, 5-3, 7-5, 11-7, 13-11.
        </para>
        <programlisting language="R">
<![CDATA[idx = which(diff==2)]]>
        </programlisting>        
        <screen>
<![CDATA[> idx = which(diff==2)
> idx
[1] 2 3 5
]]>
        </screen>              
        <para>
            Megnézi a <varname>diff</varname>-ben, hogy melyiknél lett kettő az eredmény, mert azok az ikerprím párok, ahol ez igaz.
            Ez a <varname>diff</varname>-ben lévő 3-2, 5-3, 7-5, 11-7, 13-11 külünbségek közül ez a 2., 3. és 5. indexűre teljesül.
        </para>
        <programlisting language="R">
<![CDATA[t1primes = primes[idx]]]>
        </programlisting>  
        <para>
            Kivette a primes-ból a párok első tagját. 
        </para>
        <programlisting language="R">
<![CDATA[t2primes = primes[idx]+2]]>
        </programlisting>        
        <para>
            A párok második tagját az első tagok kettő hozzáadásával képezzük.
        </para>
        <programlisting language="R">
<![CDATA[rt1plust2 = 1/t1primes+1/t2primes]]>
        </programlisting>        
        <para>
            Az 1/t1primes a t1primes 3,5,11 értékéből az alábbi reciprokokat képzi:
        </para>
        <screen>
<![CDATA[> 1/t1primes
[1] 0.33333333 0.20000000 0.09090909
]]>
        </screen>                      
        <para>
            Az 1/t2primes a t2primes 5,7,13 értékéből az alábbi reciprokokat képzi:
        </para>
        <screen>
<![CDATA[> 1/t2primes
[1] 0.20000000 0.14285714 0.07692308
]]>
        </screen>                      
        <para>
            Az 1/t1primes + 1/t2primes pedig ezeket a törteket rendre összeadja.
        </para>
        <screen>
<![CDATA[> 1/t1primes+1/t2primes
[1] 0.5333333 0.3428571 0.1678322
]]>
        </screen>                      
        <para>
            Nincs más dolgunk, mint ezeket a törteket összeadni a 
            <function>sum</function> függvénnyel.
        </para>
        
        <programlisting language="R">
<![CDATA[sum(rt1plust2)]]>
        </programlisting>    
        <screen>
<![CDATA[>   sum(rt1plust2)
[1] 1.044023
]]>
        </screen>            
        <para>
            A következő ábra azt mutatja, hogy a szumma értéke, hogyan nő, egy határértékhez tart, a 
            B<subscript>2</subscript> Brun konstanshoz. Ezt ezzel a csipettel rajzoltuk ki, ahol először a fenti 
            számítást 13-ig végezzük, majd 10013, majd 20013-ig, egészen 990013-ig, azaz közel 1 millióig.
            Vegyük észre, hogy az ábra első köre, a 13 értékhez tartozó 1.044023.
        </para>
        <programlisting language="R">
<![CDATA[x=seq(13, 1000000, by=10000)
y=sapply(x, FUN = stp)
plot(x,y,type="b")]]>
        </programlisting>          
        <figure>
            <title>A B<subscript>2</subscript> konstans közelítése</title>
            <mediaobject>
                <imageobject>
                    <imagedata fileref="img/BrunKorok.png" scale="50" />
                </imageobject>
                <textobject>
                    <phrase>A B<subscript>2</subscript> konstans közelítése</phrase>
                </textobject>
            </mediaobject>
        </figure>
        <para>
            Ezek után érdemes lehet felvetni a kérdést, hogy ha az ikerprímek (p; p+2) reciprokainak összege
            a B<subscript>2</subscript> konstans konvergálnak, akkor vajon a prímnégyesek (p; p+2; p+6; p+8) reciprokai is konvergálnak-e
            valahova? 
        </para>                             
        <tip>
            <title>Werkfilm</title>
            <itemizedlist>
                <listitem>
                    <para>
                        <link xlink:href="https://youtu.be/VkMFrgBhN1g">https://youtu.be/VkMFrgBhN1g</link>
                    </para>    
                </listitem>                
                <listitem>
                    <para>
                        <link xlink:href="https://youtu.be/aF4YK6mBwf4">https://youtu.be/aF4YK6mBwf4</link>
                    </para>    
                </listitem>                
            </itemizedlist>                
        </tip>
    </section>

</chapter>                
