<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <info>
        <title>Helló, Conway!</title>
        <keywordset>
            <keyword/>
        </keywordset>
    </info>
    <note>
        <title>Futtatási videó: </title>
        <para><link xlink:href="https://youtu.be/qiZUY0LIs2w">https://youtu.be/qiZUY0LIs2w</link></para>
    </note>
    <!--
    <section>
        <title>Passz: Hangyaszimulációk</title>
        <para>
            Írj Qt C++-ban egy hangyaszimulációs programot, a forrásaidról utólag reverse engineering jelleggel
            készíts UML osztálydiagramot is!
        </para>
        <para>
            Megoldás videó: <link xlink:href="https://bhaxor.blog.hu/2018/10/10/myrmecologist">https://bhaxor.blog.hu/2018/10/10/myrmecologist</link>
        </para>
        <para>
            Megoldás forrása: <link xlink:href=""></link>               
        </para>
        <para>
            Ebben a feladatban a hangyák mozgását fogjuk szimulálni. Fontos megjegyezni, hogy a hangyák nem csak össze-vissza 
            mozognak, hanem tájékozódnak. Méghozzá fejlett szaglásuk segítségével követik egymás feromon nyomát. Ennek főleg 
            akkor van szerepe, ha valamelyik hangya talál valamit (pl. ételt), akkor a megfelelő szagminta kibocsátásával 
            oda csalhatja a társait, hogy segítsenek. Ennek a legnagyobb szerepe ott van, hogy a hangyák mozgásának a tanulmányozásával 
            megfigyelhetjük, hogy hogyan találják meg így a legrövidebb útvonalat. Ezek az ismeretek sokat segíthetnek azútkereső algoritmusoknak 
            is (lásd. navmesh). 
        </para>
        <para>
            Kezdésnek nézzük meg a hangyáinkat: 
        </para> 
        <programlisting language='c++'>
            <![CDATA[ #ifndef ANT_H
            #define ANT_H
            
            class Ant
            {
            
            public:
                int x;
                int y;
                int dir;
            
                Ant(int x, int y): x(x), y(y) {
                    
                    dir = qrand() % 8;
                    
                }
            
            };
            
            typedef std::vector<Ant> Ants;
            
            #endif]]>
        </programlisting>   
        <para>
            A main.cpp-ben első sorban lekezeljük a lehetséges argumentumokat, a program hívásához (úgy mint az ablak méretét, 
            a hangyák sebességét, számát, stb). Ezeket pedig átadjuk az ablak elkészítéséhez. Itt még szerepel a qsrand, ami a 
            véletlenszerű irány meghatározásához fog használni a hangyánk.   
        </para>
        <para>
            Nézzük meg az antwin.cpp-t: 
        </para>   
        <programlisting language='c++'><![CDATA[
            void AntWin::paintEvent ( QPaintEvent* )
            {
                QPainter qpainter ( this );
            
                grid = grids[gridIdx];
            
                for ( int i=0; i<height; ++i ) {
                    for ( int j=0; j<width; ++j ) {
            
                        double rel = 255.0/max;
            
                        qpainter.fillRect ( j*cellWidth, i*cellHeight,
                                            cellWidth, cellHeight,
                                            QColor ( 255 - grid[i][j]*rel,
                                                     255,
                                                     255 - grid[i][j]*rel) );
            
                        if ( grid[i][j] != min )
                        {
                            qpainter.setPen (
                                QPen (
                                    QColor ( 255 - grid[i][j]*rel,
                                             255 - grid[i][j]*rel, 255),
                                    1 )
                            );
            
                            qpainter.drawRect ( j*cellWidth, i*cellHeight,
                                                cellWidth, cellHeight );
                        }
            
            
            
                        qpainter.setPen (
                            QPen (
                                QColor (0,0,0 ),
                                1 )
                        );
            
                        qpainter.drawRect ( j*cellWidth, i*cellHeight,
                                            cellWidth, cellHeight );
            
                    }
                }
            
                for ( auto h: *ants) {
                    qpainter.setPen ( QPen ( Qt::black, 1 ) );
            
                    qpainter.drawRect ( h.x*cellWidth+1, h.y*cellHeight+1,
                                        cellWidth-2, cellHeight-2 );
            
                }
            
                qpainter.end();
            }]]>
            </programlisting>
            <para>
                Itt a <function>paintEvent</function> van kiemelve, mely a GUI újrarajzolásáért felel (példáúl mikor az update függvény 
                lefut). Amit csinál az alapvetőleg egyszerű, mert csak kirajzolja a világot, a feromon nyomot és a hangyáinkat. 
            </para>
            <para>
                Folyt. köv. 
            </para>     
    </section>
-->        
<!--
    <section>
        <title>Passz: Java életjáték</title>
        <para>
            Írd meg Java-ban a John Horton Conway-féle életjátékot, 
            valósítsa meg a sikló-kilövőt!
        </para>
        <para>
            Megoldás videó: 
        </para>
        <para>
            Megoldás forrása: <link xlink:href=""></link>               
        </para>
                 
    </section> 
-->
    
    <section>
        <title>Extra: Sejtautomaták a játékiparban: </title>
        <para>
            Lehet pár embernek meglepő, de a játékiparban sok olyan algoritmust használnak, melyről nem is gondolnánk hogy erre is alkalmazható. Ilyenek a sejtautomaták is, amilyen Conway életjátéka 
            is. Ebben a példában  Sebastian Lague mutatja be, hogy hogyan is lehet ezt az algoritmust felhasználni procedurálisan generált barlangok készítéséhez. Érdemes lehet megnézni más videóit is, 
            mert nagyon igényes és érdekes tartalmakat készít. 
            A videó: <link xlink:href="https://youtu.be/v7yyZZjF1z4">https://youtu.be/v7yyZZjF1z4</link>
            A Github repoja: <link xlink:href="https://github.com/SebLague/Procedural-Cave-Generation">https://github.com/SebLague/Procedural-Cave-Generation</link>
        </para>
        <para>
            Ebből a hangyabolyból...
        </para>
        <mediaobject>
            <imageobject>
                <imagedata fileref="Pics/CellAutoFrom.png" scale="25" />
            </imageobject>
            <textobject>
                <phrase>Ebből a hangyabolyból...</phrase>
            </textobject>
        </mediaobject>
        <para>
            ...ez a szép barlang lett:
        </para>
        <mediaobject>
            <imageobject>
                <imagedata fileref="Pics/CellAutoTo.png" scale="25" />
            </imageobject>
            <textobject>
                <phrase>...ez a szép barlang lett</phrase>
            </textobject>
        </mediaobject>
        <para>
            Mivel ez egy nyílvános repó és tutoriál anyag, ezért remélem nem gond, ha megosztom a forráskódot elemzés céljára. Minden jog fenttartva Sebastian részére. 
        </para>
        <programlisting>
<![CDATA[
using UnityEngine;
using System.Collections;
using System;

public class MapGenerator : MonoBehaviour {

	public int width;
	public int height;

	public string seed;
	public bool useRandomSeed;

	[Range(0,100)]
	public int randomFillPercent;

	int[,] map;

	void Start() {
		GenerateMap();
	}

	void Update() {
		if (Input.GetMouseButtonDown(0)) {
			GenerateMap();
		}
	}

	void GenerateMap() {
		map = new int[width,height];
		RandomFillMap();

		for (int i = 0; i < 5; i ++) {
			SmoothMap();
		}
	}


	void RandomFillMap() {
		if (useRandomSeed) {
			seed = Time.time.ToString();
		}

		System.Random pseudoRandom = new System.Random(seed.GetHashCode());

		for (int x = 0; x < width; x ++) {
			for (int y = 0; y < height; y ++) {
				if (x == 0 || x == width-1 || y == 0 || y == height -1) {
					map[x,y] = 1;
				}
				else {
					map[x,y] = (pseudoRandom.Next(0,100) < randomFillPercent)? 1: 0;
				}
			}
		}
	}

	void SmoothMap() {
		for (int x = 0; x < width; x ++) {
			for (int y = 0; y < height; y ++) {
				int neighbourWallTiles = GetSurroundingWallCount(x,y);

				if (neighbourWallTiles > 4)
					map[x,y] = 1;
				else if (neighbourWallTiles < 4)
					map[x,y] = 0;

			}
		}
	}

	int GetSurroundingWallCount(int gridX, int gridY) {
		int wallCount = 0;
		for (int neighbourX = gridX - 1; neighbourX <= gridX + 1; neighbourX ++) {
			for (int neighbourY = gridY - 1; neighbourY <= gridY + 1; neighbourY ++) {
				if (neighbourX >= 0 && neighbourX < width && neighbourY >= 0 && neighbourY < height) {
					if (neighbourX != gridX || neighbourY != gridY) {
						wallCount += map[neighbourX,neighbourY];
					}
				}
				else {
					wallCount ++;
				}
			}
		}

		return wallCount;
	}


	void OnDrawGizmos() {
		if (map != null) {
			for (int x = 0; x < width; x ++) {
				for (int y = 0; y < height; y ++) {
					Gizmos.color = (map[x,y] == 1)?Color.black:Color.white;
					Vector3 pos = new Vector3(-width/2 + x + .5f,0, -height/2 + y+.5f);
					Gizmos.DrawCube(pos,Vector3.one);
				}
			}
		}
	}

} 
]]>
        </programlisting>
    </section>

    <section>
        <title>Qt C++ életjáték</title>
        <para>
            Most Qt C++-ban!
        </para>
        <para>
            Megoldás videó: 
        </para>
        <para>
            Megoldás forrása: <link xlink:href=""></link>               
        </para>
        <para>
            Az életjáték (Game of Life) John Conway Brit matematikus munkája. Játék ként van említve, de a passzív játék megnevezés 
            talán ponstosabb, ugyanis a játékosnak a kezdő alakzat megrajzolásán túl nem sok szerepe van a játékban, inkább megfigyelőként 
            vsz részt. Érdekes, hogy egy időben ez egy aránylag népszerű játék volt Amerikában. 
        </para>        
        <para>
            A játék menete: 
            Adott egy tábla (négyzetháló) ahova a játékos pontokat, úgynevezett sejteket helyezhet el. A játék körökből áll, melyek 
            generációk ként van meghivatkozva. Ezekben a körökben a sejtünk vagy túlél, vagy elpusztúl, vagy szaporodik. Hogy az adott körben 
            melyik törénik azt három egyszerű szabály határozza meg, a szomszédok számának függvényében (egy sejtnek 8 szomszéda lenne):  
        </para>    
        <itemizedlist mark='bullet'>
            <listitem>
                <para>
                    Egy sejt 2 vagy 3 élő szomszéd esetében életben marad.
                </para>
            </listitem>
            <listitem>
                <para>
                    Egy sejt elpusztul ha 2-nél kevesebb vagy 3-nál több élő szomszédja van
                </para>
            </listitem>
            <listitem>
                <para>
                    Egy új sejt születik, ha pontosan 3 élő szomszédja van.
                </para>
            </listitem>
        </itemizedlist>  
        <para>
            Ezekkel az egyszerű szabályokkal viszont lehetőségünk van olyan speciális alakzatokra is mint példáúl a sikló (glider) 
            melynek a különlegessége, hogy pár lépésen belül vissza alakúl saját magává, viszont pár egységgel odébb, ezáltal mozog.
        </para>
        <para>
            A szabályok és a speciális alakzatok kihasználásával pedig létrehozhatunk akár komplex automatákat. Egy ilyet mutat be az alábbi 
            program is. Ennek az automatának a neve Glider Gun (siklóágyú), melyet Bill Gosper alkotott meg és remekűl reprezentálja, hogy 
            mennyi mindent lehet csinálni még egy ilyen egyszerű játékkal is. 
        </para>
        <para> 
            Kezdjük a sejtablak.cpp-vel: 
        </para>       
        <programlisting language='c++'><![CDATA[
            SejtAblak::SejtAblak(int szelesseg, int magassag, QWidget *parent)
            : QMainWindow(parent)
            {
            setWindowTitle("A John Horton Conway-féle életjáték");
            
            this->magassag = magassag;
            this->szelesseg = szelesseg;

            
            cellaSzelesseg = 6;
            cellaMagassag = 6;

            setFixedSize(QSize(szelesseg*cellaSzelesseg, magassag*cellaMagassag));
            
            racsok = new bool**[2];
            racsok[0] = new bool*[magassag];
            for(int i=0; i<magassag; ++i)
                racsok[0][i] = new bool [szelesseg];
            racsok[1] = new bool*[magassag];
            for(int i=0; i<magassag; ++i)
                racsok[1][i] = new bool [szelesseg];

            racsIndex = 0;
            racs = racsok[racsIndex];

            // A kiinduló racs minden cellája HALOTT
            for(int i=0; i<magassag; ++i)
                for(int j=0; j<szelesseg; ++j)
                racs[i][j] = HALOTT;
                // A kiinduló racsra "ELOlényeket" helyezünk
                //siklo(racs, 2, 2);

                sikloKilovo(racs, 5, 60);

            eletjatek = new SejtSzal(racsok, szelesseg, magassag, 120, this);

            eletjatek->start();
        
            }]]>
        </programlisting>
        <para>
            Itt alapozzuk meg az ablakunkat. Meghatározzunk olyanokat, mint az ablak dimenzióit és a cellaméretet. Létrehozzuk a két rácsunkat. 
            A rácspontokat beállítjuk halott sejteknek, mivel majd csak ezután helyezzük el az automatánkat. Ezután meghívjuk a <function>sikloKilovo</function>
            függvényt, amely egyszerűen csak meghatározza, hogy a sikló ágyú kiinduló állapotához, mely sejteknek kell élőnek lennie és ezeket a 
            rácspontokat halottról élőre állítja. Végül elindítjuk magát a játékot. Egy részt külön kiemelnék innen: 
        </para>
        <programlisting language="c++">
<![CDATA[ 
racsok = new bool**[2];
racsok[0] = new bool*[magassag];
for(int i=0; i<magassag; ++i)
    racsok[0][i] = new bool [szelesseg];
racsok[1] = new bool*[magassag];
for(int i=0; i<magassag; ++i)
    racsok[1][i] = new bool [szelesseg];
]]>
        </programlisting>
        <para>
            Az elv nagyon hasonló mint a Caesar fejezet első feladatában szereplő double ** alsó háromszögmátrixhoz. Itt két rácsot 
            akarunk kapni, melyhez a tárban foglalunk helyet. A típusuk <type>bool**</type> mert <type>boolean</type> mátrixokat szeretnénk. 
            Azaz egy tömbben tárolnunk kell a sorokat, egy másikban pedig az oszlopokat. Azért kell belőle kettő (mármint mátrixból), 
            mert az életjáték egy fontos szabálya, hogy nem születhet ott új sejt ahol az előző iterációban egy sejt meghalt. 
        </para>
        <para>
            Utánna még egy dupla for ciklus végig halad és a rácscelláknak <type>halott</type> értékre állítja, majd meghívja a <function>sikloKilovo</function> 
            függvényt, mely a megfelelő cellákat élőre állítja, hogy a siklógyárunk harcra kész legyen a szimuláció indításakor. 
        </para>
        <para>
            Itt még található egy <function>paintEvent</function> ami a GUI kirajzolásáért és 
            frissitésenkénti újrarajzolásáért felel. Minden híváskor végighalad az aktuálisan használt rácson és megnézi, hogy az adott sejt él-e még. 
            Amennyiben igen, a színét feketére állítja, ellenkező esetben fehérre.
        </para>
        <programlisting language='c++'>
            <![CDATA[ 
            void SejtAblak::paintEvent(QPaintEvent*) {
                QPainter qpainter(this);
                
                // Az aktuális
                bool **racs = racsok[racsIndex];
                // racsot rajzoljuk ki:
                for(int i=0; i<magassag; ++i) { // végig lépked a sorokon
                  for(int j=0; j<szelesseg; ++j) { // s az oszlopok
                    // Sejt cella kirajzolása
                    if(racs[i][j] == ELO)
                  qpainter.fillRect(j*cellaSzelesseg, i*cellaMagassag,
                            cellaSzelesseg, cellaMagassag, Qt::black);
                  else
                    qpainter.fillRect(j*cellaSzelesseg, i*cellaMagassag,
                              cellaSzelesseg, cellaMagassag, Qt::white);
                    qpainter.setPen(QPen(Qt::gray, 1));
                  
                  qpainter.drawRect(j*cellaSzelesseg, i*cellaMagassag,
                            cellaSzelesseg, cellaMagassag);
                  }
                }
                
                qpainter.end();
              }]]>
        </programlisting>
        <para>
            Ezen túl van még egy destruktorunk (mely megszokott módon a lefoglalt tárak felszabadításáért felel, miután a játéknak vége) 
            és egy vissza függvény ami csak lépteti a játékot és frissití az update függvénnyel, ezáltal 
            kikényszerítve az újrarajzolást. 
        </para>
        <programlisting language='c++'>
            <![CDATA[ 
            SejtAblak::~SejtAblak()
            {
            delete eletjatek;
            
            for(int i=0; i<magassag; ++i) {
                delete[] racsok[0][i];
                delete[] racsok[1][i];
            }
            
            delete[] racsok[0];
            delete[] racsok[1];
            delete[] racsok;
            
            
            }

            void SejtAblak::vissza(int racsIndex)
            {
            this->racsIndex = racsIndex;
            update();
            }]]>
        </programlisting>
        <para>
            A játéktér készen áll, már csak a játékszabályokat kell fixálni és kezdődhet is a szimuláció. 
        </para>
        <para>
            A sejtszal.cpp tartalmazza lényegében az alapszabályokat. Az elején található a konstruktor, de az az értékek átadásán kívül 
            nem sok érdekeset csinál szóval azt  itt nem taglalnám hossza. Viszont az első függvényünk itt a <function>szomszedokSzama</function> 
            meghatározza a szomszédok számát, mely segítségével eldönthetjük, hogy az adott körben a sejt életben marad-e vagy szaporodik-e vagy esetleg elpusztul.
            Ez a játéknak a legfontosabb része, a szíve-lelke mondhatni. Az utolsó paramétere egy <type>boolean</type> aminek megíváskor az ELO 
            értéket adjuk ét, tehát a függvény azt számolja, hogy egy adott cellának hány darab ÉLŐ szomszédja van. Két darab forciklus végig megy 
            a 3x3-as területen, viszont egy if-el kihagyjuk a középső elemet, azaz a sejtet magát akinek a szomszédjait vizsgáljuk. Végül végighaladunk 
            a vizsgálni kívánt elemeken és ha élőtt találunk, akkor növeljük a <varname>allapotuSzomszed</varname>-ot, majd annak értékével visszatérünk.  
        </para>
        <programlisting language='c++'>
            <![CDATA[ 
            int SejtSzal::szomszedokSzama(bool **racs,
                              int sor, int oszlop, bool allapot) {
                int allapotuSzomszed = 0;
                // A nyolcszomszédok végigzongorázása:
                for(int i=-1; i<2; ++i)
                    for(int j=-1; j<2; ++j)
                        // A vizsgált sejtet magát kihagyva:
                        if(!((i==0) && (j==0))) {
                    // A sejttérből szélének szomszédai
                    // a szembe oldalakon ("periódikus határfeltétel")
                    int o = oszlop + j;
                    if(o < 0)
                        o = szelesseg-1;
                    else if(o >= szelesseg)
                        o = 0;

                    int s = sor + i;
                    if(s < 0)
                        s = magassag-1;
                    else if(s >= magassag)
                        s = 0;

                    if(racs[s][o] == allapot)
                        ++allapotuSzomszed;
                }

            return allapotuSzomszed;
        }]]>
        </programlisting>
        <para>
            Az <function>IdoFejlodes</function> pedig meghatározza, hogy a szomszéd szám alapjáán ténylegesen mi lesz a sejttel. Ugye az 
            előbbi bekezdés alapján 3 állapot állhat elő. Ehhez szükségünk lesz mindkét rácsunkra. Az egyik ugye a számítás előtti, a másik pedig az utánni, 
            azaz a következő kör/iteráció már az új rácson folytatódhasson. Ezeken a rácsokon megint csak végig kell lépkednünk, minden cellának le 
            kell kérnünk a szomszédjainak a számát, melyet az előbb taglalt függvénnyel teszünk meg. Majd megállapítjuk, hogy az adott sejt 
            él-e még. Ha igen akkor pontosan 2 vagy 3 szomszéddal kell rendelkezni-e a túléléshez, ha ettől több vagy kevesebb, akkor a sejt elpusztúl. 
            Viszont ha az adott sejt halott volt, de pontosan 3 élő szomszédja van, akkor ott új sejt születik. 
        </para>
        <programlisting language='c++'>
            <![CDATA[ 
            void SejtSzal::idoFejlodes() {

                bool **racsElotte = racsok[racsIndex];
                bool **racsUtana = racsok[(racsIndex+1)%2];
            
                for(int i=0; i<magassag; ++i) { // sorok
                    for(int j=0; j<szelesseg; ++j) { // oszlopok
            
                        int elok = szomszedokSzama(racsElotte, i, j, SejtAblak::ELO);
            
                        if(racsElotte[i][j] == SejtAblak::ELO) {
                            /* Élő élő marad, ha kettő vagy három élő
                         szomszedja van, különben halott lesz. */
                            if(elok==2 || elok==3)
                                racsUtana[i][j] = SejtAblak::ELO;
                            else
                                racsUtana[i][j] = SejtAblak::HALOTT;
                        }  else {
                            /* Halott halott marad, ha három élő
                         szomszedja van, különben élő lesz. */
                            if(elok==3)
                                racsUtana[i][j] = SejtAblak::ELO;
                            else
                                racsUtana[i][j] = SejtAblak::HALOTT;
                        }
                    }
                }
                racsIndex = (racsIndex+1)%2;
            }
            ]]>
        </programlisting>
        <para>
            Ez volt a conway élet játékának egy kis példája. Az eredeti játékban van lehetőségünk meghatározni, hogy melyik sejt kezdjen élve. 
            Viszont akiket érdekel ez a téma és elég kitartóak azok kipróbálhatják a manuális életjátékát is, mivel hogy a szabályok ismeretében 
            ez a játék táblán is játszható, csak kicsit hosszabb időt vesznek igénybe az iterációk és lehet nem lesz olyan látványos.  
        </para>          
    </section>        
    <section>
        <title>BrainB Benchmark</title>
        <para>
        </para>
        <para>
            Megoldás videó: 
        </para>
        <para>
            Megoldás forrása: <link xlink:href=""></link>               
        </para>
        <para>
            Ennek a játéknak a lényege, hogy játékosok, esportolók kognitív képességeit hivatott felmérni. A játék 10 percig tart és a 
            feladat egyszerű. A samu nevű entitáson kell tartanunk a mutót amíg csak tudjuk. Viszont samu mozog és bizonyos időközönként új 
            entitások jelennek meg, hogy megzavarják a játékost. És ha ez nem lenne elég, ugye a játék 10 percig tart, így ez is kihívást jelenthet 
            a játékosok számára. 
        </para>
        <para>
            A játék legfontosabb mechanikája a BrainBWin.cpp-ben található, méghozzá az <function>updateHeroes</function> függvény. 
        </para>   
        <programlisting language='c++'>
            <![CDATA[ void BrainBWin::updateHeroes ( const QImage &image, const int &x, const int &y )
            {
            
                    if ( start && !brainBThread->get_paused() ) {
            
                            int dist = ( this->mouse_x - x ) * ( this->mouse_x - x ) + ( this->mouse_y - y ) * ( this->mouse_y - y );
            
                            if ( dist > 121 ) {
                                    ++nofLost;
                                    nofFound = 0;
                                    if ( nofLost > 12 ) {
            
                                            if ( state == found && firstLost ) {
                                                    found2lost.push_back ( brainBThread->get_bps() );
                                            }
            
                                            firstLost = true;
            
                                            state = lost;
                                            nofLost = 0;
                                            //qDebug() << "LOST";
                                            //double mean = brainBThread->meanLost();
                                            //qDebug() << mean;
            
                                            brainBThread->decComp();
                                    }
                            } else {
                                    ++nofFound;
                                    nofLost = 0;
                                    if ( nofFound > 12 ) {
            
                                            if ( state == lost && firstLost ) {
                                                    lost2found.push_back ( brainBThread->get_bps() );
                                            }
            
                                            state = found;
                                            nofFound = 0;
                                            //qDebug() << "FOUND";
                                            //double mean = brainBThread->meanFound();
                                            //qDebug() << mean;
            
                                            brainBThread->incComp();
                                    }
            
                            }
            
                    }
                    pixmap = QPixmap::fromImage ( image );
                    update();
            }]]>
        </programlisting>      
        <para>
            Ha a játék el van indítva és nincs szüneteltetve akkor folyamatosan figyeli ez a függvény, hogy a játékos épp samura mutat-s vagy 
            elvesztette és ha igen, akkor hányszor, továbbá, hogy hászor találja meg elvesztés után. Azt hogy elvesztette-e samut azt úgy hatűrozza meg, hogy
             figyeli samu és a kurzor közti távolságot. Ha ez meghaladja a 121 egységet akkor elveszítjük samut. 
        </para>               
    </section>    
    <section>
        <title>Malmo</title>
        <para>
            Megoldás videó: <link xlink:href="https://youtu.be/WRDt8ljy_hI">https://youtu.be/WRDt8ljy_hI</link>
        </para>
        <para>
            Ennél a feladatnál az volt a célunk, hogy egy kapott kódot módosítsunk, továbbfejlesszük.
        </para>
        <programlisting language="python">
<![CDATA[ 
from __future__ import print_function
# ------------------------------------------------------------------------------------------------
# Copyright (c) 2016 Microsoft Corporation
# 
# Permission is hereby granted, free of charge, to any person obtaining a copy of this software and
# associated documentation files (the "Software"), to deal in the Software without restriction,
# including without limitation the rights to use, copy, modify, merge, publish, distribute,
# sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
# 
# The above copyright notice and this permission notice shall be included in all copies or
# substantial portions of the Software.
# 
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT
# NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
# DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
# ------------------------------------------------------------------------------------------------

# Tutorial sample #2: Run simple mission using raw XML

# Added modifications by Norbert Bátfai (nb4tf4i) batfai.norbert@inf.unideb.hu, mine.ly/nb4tf4i.1
# 2018.10.18, https://bhaxor.blog.hu/2018/10/18/malmo_minecraft
# 2020.02.02, NB4tf4i's Red Flowers, http://smartcity.inf.unideb.hu/~norbi/NB4tf4iRedFlowerHell
# 2020.03.02, https://github.com/nbatfai/RedFlowerHell
# 2020.03.07, "_smartSteve": nof_turn (number of turns) is replaced by the dict self.collectedFlowers 
# 2020.03.11, "_bu": bottom up, s4v3: https://youtu.be/VP0kfvRYD1Y

from builtins import range
import MalmoPython
import os
import sys
import time
import random
import json
import math

if sys.version_info[0] == 2:
    sys.stdout = os.fdopen(sys.stdout.fileno(), 'w', 0)  # flush print output immediately
else:
    import functools
    print = functools.partial(print, flush=True)

# Create default Malmo objects:

agent_host = MalmoPython.AgentHost()
try:
    agent_host.parse( sys.argv )
except RuntimeError as e:
    print('ERROR:',e)
    print(agent_host.getUsage())
    exit(1)
if agent_host.receivedArgument("help"):
    print(agent_host.getUsage())
    exit(0)

# -- set up the mission -- #
missionXML_file='nb4tf4i_d.xml'
with open(missionXML_file, 'r') as f:
    print("NB4tf4i's Red Flowers (Red Flower Hell) - DEAC-Hackers Battle Royale Arena\n")
    print("NB4tf4i vörös pipacsai (Vörös Pipacs Pokol) - DEAC-Hackers Battle Royale Arena\n")
    print("The aim of this first challenge, called nb4tf4i's red flowers, is to collect as many red flowers as possible before the lava flows down the hillside.\n")
    print("Ennek az első, az nb4tf4i vörös virágai nevű kihívásnak a célja összegyűjteni annyi piros virágot, amennyit csak lehet, mielőtt a láva lefolyik a hegyoldalon.\n")    
    print("Norbert Bátfai, batfai.norbert@inf.unideb.hu, https://arato.inf.unideb.hu/batfai.norbert/\n")
    print("Version history\n", "Code: ", sys.argv[0], ", series 4 v.3, bottom up, max 18 poppies. Norbert Bátfai, nbatfai@gmail.com\n")
    print("Loading mission from %s" % missionXML_file)
    mission_xml = f.read()
    my_mission = MalmoPython.MissionSpec(mission_xml, True)
    my_mission.drawBlock( 0, 0, 0, "lava")

class Hourglass:
    def __init__(self, charSet):
        self.charSet = charSet
        self.index = 0
    def cursor(self):
        self.index=(self.index+1)%len(self.charSet)
        return self.charSet[self.index]

hg = Hourglass('|/-\|')

class Steve:
    def __init__(self, agent_host):
        self.agent_host = agent_host
        
        self.x = 0
        self.y = 0
        self.z = 0
        self.yaw = 0
        self.pitch = 0
        
        self.front_of_me_idx = 0
        self.front_of_me_idxr = 0
        self.front_of_me_idxl = 0        
        self.right_of_me_idx = 0
        self.left_of_me_idx = 0        
        
        self.nof_red_flower = 0
        self.lookingat = ""
        self.attackLvl = 0
        
        self.collectedFlowers = {}
        for i in range(100):
            self.collectedFlowers[i] = False

        self.collectedFlowers[1] = True
        self.collectedFlowers[2] = True

    def checkInventory(self, observations):
        for i in range(2):
            hotbari = 'Hotbar_'+str(i)+'_item'
            hotbars = 'Hotbar_'+str(i)+'_size'
            slot0_contents = observations.get(hotbari, "")
            if slot0_contents == "red_flower":
                slot0_size = observations.get(hotbars, "")
                if self.nof_red_flower < slot0_size :
                    self.nof_red_flower = slot0_size                                            
                    print("            A RED FLOWER IS MINED AND PICKED UP")
                    print("            Steve's lvl: ", self.y, "Flower lvl: ", self.attackLvl) 
                    self.collectedFlowers[self.attackLvl] = True
                    self.agent_host.sendCommand( "look -1" )
                    time.sleep(.4)
                    if self.lvlUp(observations.get("nbr3x3", 0)):
                        return True
    def pickUp(self):
        self.agent_host.sendCommand( "attack 1" )
        time.sleep(.23)#.23
        self.attackLvl = self.y

    def lvlUp(self, nbr):
        if self.collectedFlowers[self.y]:
            #self.turnToWall(nbr)
            if nbr[self.left_of_me_idx+9]=="dirt":
                self.agent_host.sendCommand( "jumpstrafe -1" )
                time.sleep(.10)#.2
            elif nbr[self.right_of_me_idx+9]=="dirt":
                self.agent_host.sendCommand( "jumpstrafe 1" )
                time.sleep(.10)#.2
            elif nbr[self.front_of_me_idx+9]=="dirt":
                self.agent_host.sendCommand( "jumpmove 1" )
                time.sleep(.10)#.2
            else:
                self.turnToWall(nbr)                
                self.agent_host.sendCommand( "move 1" )
                time.sleep(.10)#.2
            return True
        else:
            return False

    def idle(self, delay):
        #print("      SLEEPING for ", delay)
        time.sleep(delay)
                                                        
    def isInTrap(self, nbr):
            
        dc = 0    
        nbri = [9,10,11,12,14,15,16,17]    
        for i in range(1, len(nbri)):
            if nbr[nbri[i]]=="dirt" :
                dc = dc + 1            
        return dc > 5
    
    def turnFromWall(self, nbr):
        if (nbr[self.right_of_me_idx+9]=="air" and nbr[self.left_of_me_idx+9]=="dirt") or (nbr[self.right_of_me_idx]=="air" and nbr[self.left_of_me_idx]=="dirt"):
            self.agent_host.sendCommand( "turn 1" )
        else:
            self.agent_host.sendCommand( "turn -1" )
        time.sleep(.2)#.2

    def turnToWall(self, nbr):
        if (nbr[self.right_of_me_idx+9]=="air" and nbr[self.left_of_me_idx+9]=="dirt") or (nbr[self.right_of_me_idx]=="air" and nbr[self.left_of_me_idx]=="dirt"):
            self.agent_host.sendCommand( "turn -1" )
        else:
            self.agent_host.sendCommand( "turn 1" )
        time.sleep(.2)#.2

    def calcNbrIndex(self):
        if self.yaw >= 180-22.5 and self.yaw <= 180+22.5 :
            self.front_of_me_idx = 1
            self.front_of_me_idxr = 2
            self.front_of_me_idxl = 0
            self.right_of_me_idx = 5
            self.left_of_me_idx = 3            
        elif self.yaw >= 180+22.5 and self.yaw <= 270-22.5 :
            self.front_of_me_idx = 2 
            self.front_of_me_idxr = 5
            self.front_of_me_idxl =1             
            self.right_of_me_idx = 8
            self.left_of_me_idx = 0            
        elif self.yaw >= 270-22.5 and self.yaw <= 270+22.5 :
            self.front_of_me_idx = 5
            self.front_of_me_idxr = 8
            self.front_of_me_idxl = 2
            self.right_of_me_idx = 7
            self.left_of_me_idx = 1                        
        elif self.yaw >= 270+22.5 and self.yaw <= 360-22.5 :
            self.front_of_me_idx = 8            
            self.front_of_me_idxr = 7
            self.front_of_me_idxl = 5          
            self.right_of_me_idx = 6
            self.left_of_me_idx = 2                        
        elif self.yaw >= 360-22.5 or self.yaw <= 0+22.5 :
            self.front_of_me_idx = 7
            self.front_of_me_idxr = 6
            self.front_of_me_idxl = 8
            self.right_of_me_idx = 3
            self.left_of_me_idx = 5                        
        elif self.yaw >= 0+22.5 and self.yaw <= 90-22.5 :
            self.front_of_me_idx = 6
            self.front_of_me_idxr = 3
            self.front_of_me_idxl = 7          
            self.right_of_me_idx = 0
            self.left_of_me_idx = 8                        
        elif self.yaw >= 90-22.5 and self.yaw <= 90+22.5 :
            self.front_of_me_idx = 3
            self.front_of_me_idxr = 0
            self.front_of_me_idxl = 6
            self.right_of_me_idx = 1
            self.left_of_me_idx = 7                        
        elif self.yaw >= 90+22.5 and self.yaw <= 180-22.5 :
            self.front_of_me_idx = 0
            self.front_of_me_idxr = 1
            self.front_of_me_idxl = 3
            self.right_of_me_idx = 2
            self.left_of_me_idx = 6                        
        else:
            print("There is great disturbance in the Force...")            

    def whatISee(self, observations):
        self.lookingat = "NOTHING"            
        if "LineOfSight" in observations:
            lineOfSight = observations["LineOfSight"] 
            self.lookingat = lineOfSight["type"]      

    def whatMyPos(self, observations):
        if "Yaw" in observations:
            self.yaw = int(observations["Yaw"])
        if "Pitch" in observations:
            self.pitch = int(observations["Pitch"])
        if "XPos" in observations:
            self.x = int(observations["XPos"])
        if "ZPos" in observations:
            self.z = int(observations["ZPos"])        
        if "YPos" in observations:
            self.y = int(observations["YPos"])        
            
    def run(self):
        world_state = self.agent_host.getWorldState()
        # Loop until mission ends:
        while world_state.is_mission_running:
            
            #print(">>> nb4tf4i arena -----------------------------------\n")
            act = self.action(world_state)
            #print("nb4tf4i arena >>> -----------------------------------\n")
            if not act:
                self.idle(.017)
            world_state = self.agent_host.getWorldState()

    def action(self, world_state):
        for error in world_state.errors:
            print("Error:", error.text)
        
        if world_state.number_of_observations_since_last_state == 0:
            #print("    NO OBSERVATIONS NO ACTIONS")
            return False
        
        input = world_state.observations[-1].text
        observations = json.loads(input)
        nbr = observations.get("nbr3x3", 0)
        #print(observations)
        
        self.whatMyPos(observations)
        print("\r    Steve's Coords: ", self.x, self.y, self.z, end='')        
        #print("    Steve's Yaw: ", self.yaw)        
        #print("    Steve's Pitch: ", self.pitch)        

        self.checkInventory(observations)
        #print("Number of flowers: ", self.nof_red_flower)

        self.whatISee(observations)
        #print("    Steve's <): ", self.lookingat)
                        
        self.calcNbrIndex()                
                        
        if self.isInTrap(nbr) :
            self.agent_host.sendCommand( "jumpmove 1" )
            time.sleep(.1)
            self.turnFromWall(nbr)
            self.agent_host.sendCommand( "jumpmove 1" )
            time.sleep(.1)            
            return True

        if self.lookingat == "red_flower":
            print(" A RED FLOWER IS FOUND (lookingat)")
            self.pickUp()
            return True
        
        for i in range(9):
            if nbr[i]=="red_flower" or nbr[i+9]=="red_flower" or nbr[i+18]=="red_flower":
                print("        I CAN SEE A RED FLOWER: ", i, " LEVEL ", self.y)
                if i == self.front_of_me_idx :
                    print("F            A RED FLOWER IS RIGTH IN FRONT OF ME")
                    self.agent_host.sendCommand( "move 1" )
                    time.sleep(.2)
                    self.agent_host.sendCommand( "look 1" )
                    time.sleep(.2)
                    print("Steve <) ", self.lookingat)
                    return True
                elif i == self.front_of_me_idxr :
                    print("R            A RED FLOWER IS RIGTH IN RIGHT OF ME")
                    self.agent_host.sendCommand( "strafe 1" )
                    time.sleep(.2)
                    return True
                elif i == self.front_of_me_idxl :
                    print("L            A RED FLOWER IS RIGTH IN LEFT OF ME")
                    self.agent_host.sendCommand( "strafe -1" )
                    time.sleep(.2)
                    return True
                elif i == 4  :
                    self.red_flower_is_mining = True
                    print("            I AM STANDING ON A RED FLOWER!!!")
                    
                    if self.pitch != 90:
                        self.agent_host.sendCommand( "look 1" )
                        print("PITCH            I AM STANDING ON A RED FLOWER!!!")
                        time.sleep(.3)
                    else:
                        print("ATTACK            I AM STANDING ON A RED FLOWER!!! LEVEL ", self.y)
                        self.pickUp()
                        self.agent_host.sendCommand( "look -1" )
                        time.sleep(.3)
                    return True
                
                else :
                    print("            I AM TURNING TO A RED FLOWER")
                    self.agent_host.sendCommand( "turn 1" )
                    time.sleep(.2)
                    return True
  
        if self.lvlUp(nbr):
            print("        LVL UP")

        if nbr[self.front_of_me_idx+9]!="air" and nbr[self.front_of_me_idx+9]!="red_flower":
            print("        THERE ARE OBSTACLES IN FRONT OF ME ",  nbr[self.front_of_me_idx], end='')
  
            self.turnFromWall(nbr)
                        
        else:
            print("        THERE IS NO OBSTACLE IN FRONT OF ME", end='')
            
            if nbr[self.front_of_me_idx]=="dirt":
                self.agent_host.sendCommand( "move 1" )
                time.sleep(.01)#013
            else:
                self.turnFromWall(nbr)                
                
        return True        

num_repeats = 1
for ii in range(num_repeats):

    my_mission_record = MalmoPython.MissionRecordSpec()

    # Attempt to start a mission:
    max_retries = 6
    for retry in range(max_retries):
        try:
            agent_host.startMission( my_mission, my_mission_record )
            break
        except RuntimeError as e:
            if retry == max_retries - 1:
                print("Error starting mission:", e)
                exit(1)
            else:
                print("Attempting to start the mission:")
                time.sleep(2)

    # Loop until mission starts:
    print("   Waiting for the mission to start")
    world_state = agent_host.getWorldState()

    while not world_state.has_mission_begun:
        print("\r"+hg.cursor(), end="")
        time.sleep(0.15)
        world_state = agent_host.getWorldState()
        for error in world_state.errors:
            print("Error:",error.text)

    print("NB4tf4i Red Flower Hell running\n")
    steve = Steve(agent_host)
    steve.run()
    print("Number of flowers: "+ str(steve.nof_red_flower))
    time.sleep(3)

print("Mission ended")
# Mission has ended.
]]>
        </programlisting>
    </section>    
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        
</chapter>                
