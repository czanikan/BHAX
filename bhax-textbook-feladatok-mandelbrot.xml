<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <info>
        <title>Helló, Mandelbrot!</title>
        <keywordset>
            <keyword/>
        </keywordset>
    </info>
    <note>
        <title>Futtatási videó: </title>
        <para><link xlink:href="https://youtu.be/oPujRCjIbB0">https://youtu.be/oPujRCjIbB0</link></para>
    </note>
    <section xml:id="bhax-textbook-feladatok-mandelbrot.Mandelbrot">
        <title>A Mandelbrot halmaz</title>
        <note>
            <title>Tutorom volt:</title>
            <para>
                Tutor Tünde
            </para>          
        </note>
        <para>
            Írj olyan C programot, amely kiszámolja a Mandelbrot halmazt!     
        </para>
        <para>
            Megoldás videó: <link xlink:href="https://youtu.be/gvaqijHlRUs">https://youtu.be/gvaqijHlRUs</link>
        </para>
        <para>
            Megoldás forrása:                
 <link xlink:href="../../../bhax/attention_raising/CUDA/mandelpngt.c++">
                <filename>bhax/attention_raising/CUDA/mandelpngt.c++</filename>
            </link> nevű állománya.            
        </para>
                <figure>
            <title>A Mandelbrot halmaz a komplex síkon</title>
            <mediaobject>
                <imageobject>
                    <imagedata fileref="img/mandel.png" scale="50" />
                </imageobject>
                <textobject>
                    <phrase>A Mandelbrot halmaz a komplex síkon</phrase>
                </textobject>
            </mediaobject>
        </figure>
        <para>
            A Mandelbrot halmazt 1980-ban találta meg Benoit Mandelbrot a 
            komplex számsíkon. Komplex számok azok a számok, amelyek körében 
            válaszolni lehet az olyan egyébként értelmezhetetlen kérdésekre, 
            hogy melyik az a két szám, amelyet összeszorozva -9-et kapunk, 
            mert ez a szám például a 3i komplex szám.
        </para>
        <para>             
            A Mandelbrot halmazt úgy láthatjuk meg, hogy a sík origója középpontú 4 
            oldalhosszúságú négyzetbe lefektetünk egy, mondjuk 800x800-as 
            rácsot és kiszámoljuk, hogy a rács pontjai mely komplex számoknak 
            felelnek meg. A rács minden pontját megvizsgáljuk a 
            z<subscript>n+1</subscript>=z<subscript>n</subscript>
            <superscript>2</superscript>+c, 
            (0&lt;=n) képlet alapján úgy, hogy a c az éppen vizsgált rácspont. 
            A z0 az origó. Alkalmazva a képletet a 
        </para>
        <itemizedlist>
            <listitem>
                <para>
                    z<subscript>0</subscript> = 0
                </para>
            </listitem>
            <listitem>
                <para>
                    z<subscript>1</subscript> = 0<superscript>2</superscript>+c = c
                </para>
            </listitem>
            <listitem>
                <para>
                    z<subscript>2</subscript> = c<superscript>2</superscript>+c
                </para>
            </listitem>
            <listitem>
                <para>
                    z<subscript>3</subscript> = (c<superscript>2</superscript>+c)<superscript>2</superscript>+c
                </para>
            </listitem>
            <listitem>
                <para>
                    z<subscript>4</subscript> = ((c<superscript>2</superscript>+c)<superscript>2</superscript>+c)<superscript>2</superscript>+c
                </para>
            </listitem>
            <listitem>
                <para>
                    ... s így tovább.
                </para>
            </listitem>
        </itemizedlist>
        <para>
            Azaz kiindulunk az origóból (z<subscript>0</subscript>) 
            és elugrunk a rács első pontjába a z<subscript>1</subscript> = c-be, 
            aztán a c-től függően a további z-kbe. Ha ez az utazás kivezet a 
            2 sugarú körből, akkor azt mondjuk, hogy az a vizsgált rácspont 
            nem a Mandelbrot halmaz eleme. Nyilván nem tudunk végtelen sok 
            z-t megvizsgálni, ezért csak véges sok z elemet nézünk meg minden 
            rácsponthoz. Ha eközben nem lép ki a körből, akkor feketére 
            színezzük, hogy az a c rácspont a halmaz része. (Színes meg úgy 
            lesz a kép, hogy változatosan színezzük, például minél későbbi 
            z-nél lép ki a körből, annál sötétebbre). 
        </para>       
        <programlisting language="c++">
            <![CDATA[
            #include <png++/png.hpp>
            #define N 500
            #define M 500
            #define MAXX 0.7
            #define MINX -2.0
            #define MAXY 1.35
            #define MINY -1.35
            void GeneratePNG( int tomb[N][M])
            {
                png::image< png::rgb_pixel > image(N, M);
                for (int x = 0; x < N; x++)
                {
                    for (int y = 0; y < M; y++)
                    {
                        image[x][y] = png::rgb_pixel(tomb[x][y], tomb[x][y], tomb[x][y]);
                    }
                }
                image.write("kimenet.png");
            }
            struct Komplex
            {
                double re, im;
            };
            int main()
            {
                int tomb[N][M];
                int i, j, k;
                double dx = (MAXX - MINX) / N;
                double dy = (MAXY - MINY) / M;
                struct Komplex C, Z, Zuj;
                int iteracio;
                for (i = 0; i < M; i++)
                {
                    for (j = 0; j < N; j++)
                    {
                        C.re = MINX + j * dx;
                        C.im = MAXY - i * dy;
                        Z.re = 0;
                        Z.im = 0;
                        iteracio = 0;
                        while(Z.re * Z.re + Z.im * Z.im < 4 && iteracio++ < 255)
                        {
                            Zuj.re = Z.re * Z.re - Z.im * Z.im + C.re;
                            Zuj.im = 2 * Z.re * Z.im + C.im;
                            Z.re = Zuj.re;
                            Z.im = Zuj.im;
                        }
                        tomb[i][j] = 256 - iteracio;
                    }
                }
                GeneratePNG(tomb);
                return 0;
            }
            ]]>
            </programlisting>
            <para>
                A Mandelbrot halmaz illeszkedik a 
                <inlineequation>
                <alt role="tex">f_c(z) = z^2 + c</alt>
                <mathphrase/>
                </inlineequation>
                függvény képére, és korlátos, mivel nullától iterálva nem divergál 
                <inlineequation>
                <alt role="tex">f_c(0), f_c(f_c(0)), ...</alt>
                <mathphrase/>
                </inlineequation>
                abszolútértékben.
            </para>
            <para>
                A program elején találtható egy GeneratePNG() függvény, mely a kiszámolt mátrix elemeiből a libpng 
                könyvtár segítségével felépít egy png képet. Ezt úgy teszi meg, hogy a main-ben már társítottunk a mátrix elemekhez 
                egy értéket, mely alapján eldönti, hogy az adott elemhez tartozó pixel milyen színű lesz (hiszen a képek is csak pixel 
                mátrixok). 
            </para>
            <para>
                Bár ez egy C++ program, hogy megjeleníthető legyen a halmaz kép formájában, de alapvetőleg C 
                alapú a kód, így a komplex számokat nem olyan triviális meghivatkozni (C++ban a complex utasítással ezt 
                könnyen megtehetjük, de erről a következő feladat fog szólni). Mivel egy komplex szám a legtöbb számmal ellentétben 
                két értékkel is rendelkezik (valós és imaginárius egység), ezért egy klasszikus számtípus nem elég. A megoldás egy 
                struktúra létrehozásában van. Ezért elkészítjük a Komplex struktúrát, mely két double értékkel fog rendelkezni. 
            </para>
            <para>
                Végül egy dupla for ciklus segítségével végig rohanunk a mátrix elemein és egyesével megvizsgájuk, 
                hogy mennyi próbálkozás után tud kilépni a halmazból (ha ki tud). Ezután 256-ból kivonjuk a próbálkozások számát. 
                Ez fogja adni a képünknek a színárnyalatát. Ha azonnal kilép, akkor nem része a halmaznak, és teljesen fehér lesz. 
                Minél tovább marad bent, annál sötétebb árnyalatott vesz fel. végül, ha 256 próbálkozás alatt, sem sikerül neki, az 
                azt jelenti, hogy része a Mandelbrot halmaznak, így teljesen fekete értéket kap.  
            </para>
            <para>
                A futtatáshoz szükséges makefile tartalma: 
            </para>
            <programlisting>
                <![CDATA[all: mandelbrot clean
                mandelbrot.o: mandelbrot.cpp
                    @g++ -c mandelbrot.cpp `libpng-config --cflags`
                mandelbrot: mandelbrot.o
                    @g++ -o mandelbrot mandelbrot.o `libpng-config --ldflags`
                clean:
                    @rm -rf *.o
                    @./mandelbrot
                    @rm -rf mandelbrot ]]>
            </programlisting>

    </section>        
        
    <section>
        <title>A Mandelbrot halmaz a <filename>std::complex</filename> osztállyal</title>
        <para>
            Írj olyan C++ programot, amely kiszámolja a Mandelbrot halmazt!                     
        </para>
        <para>
            Megoldás videó: <link xlink:href="https://youtu.be/gvaqijHlRUs">https://youtu.be/gvaqijHlRUs</link>
        </para>
        <para>
            Megoldás forrása:                
        </para>
        <para>        
A <link xlink:href="#bhax-textbook-feladatok-mandelbrot.Mandelbrot">Mandelbrot halmaz</link> pontban vázolt
ismert algoritmust valósítja meg a repó <link xlink:href="../../../bhax/attention_raising/Mandelbrot/3.1.2.cpp">
                <filename>bhax/attention_raising/Mandelbrot/3.1.2.cpp</filename>
            </link> nevű állománya.
        </para>
        
        <programlisting language="c++">
<![CDATA[// Verzio: 3.1.2.cpp
// Forditas:
// g++ 3.1.2.cpp -lpng -O3 -o 3.1.2
// Futtatas:
// ./3.1.2 mandel.png 1920 1080 2040 -0.01947381057309366392260585598705802112818 -0.0194738105725413418456426484226540196687 0.7985057569338268601555341774655971676111 0.798505756934379196110285192844457924366
// ./3.1.2 mandel.png 1920 1080 1020 0.4127655418209589255340574709407519549131 0.4127655418245818053080142817634623497725 0.2135387051768746491386963270997512154281 0.2135387051804975289126531379224616102874
// Nyomtatas:
// a2ps 3.1.2.cpp -o 3.1.2.cpp.pdf -1 --line-numbers=1  --left-footer="BATF41 HAXOR STR34M" --right-footer="https://bhaxor.blog.hu/" --pro=color
// ps2pdf 3.1.2.cpp.pdf 3.1.2.cpp.pdf.pdf
//
//
// Copyright (C) 2019
// Norbert Bátfai, batfai.norbert@inf.unideb.hu
//
//  This program is free software: you can redistribute it and/or modify
//  it under the terms of the GNU General Public License as published by
//  the Free Software Foundation, either version 3 of the License, or
//  (at your option) any later version.
//
//  This program is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FORA program elején találtható egy GeneratePNG() függvény, mely a kiszámolt mátrix elemeiből a libpng 
                könyvtár segítségével felépít egy png képet. Ezt úgy teszi meg, hogy a main-ben már társítottunk a mátrix elemekhez 
                egy értéket, mely alapján eldönti, hogy az adott elemhez tartozó pixel milyen színű lesz (hiszen a képek is csak pixel 
                mátrixok). y of the GNU General Public License
//  along with this program.  If not, see <https://www.gnu.org/licenses/>.


#include <iostream>
#include "png++/png.hpp"
#include <complex>

int
main ( int argc, char *argv[] )
{

  int szelesseg = 1920;
  int magassag = 1080;
  int iteraciosHatar = 255;
  double a = -1.9;
  double b = 0.7;
  double c = -1.3;
  double d = 1.3;

  if ( argc == 9 )
    {
      szelesseg = atoi ( argv[2] );
      magassag =  atoi ( argv[3] );
      iteraciosHatar =  atoi ( argv[4] );
      a = atof ( argv[5] );
      b = atof ( argv[6] );
      c = atof ( argv[7] );
      d = atof ( argv[8] );
    }
  else
    {
      std::cout << "Hasznalat: ./3.1.2 fajlnev szelesseg magassag n a b c d" << std::endl;
      return -1;
    }

  png::image < png::rgb_pixel > kep ( szelesseg, magassag );

  double dx = ( b - a ) / szelesseg;
  double dy = ( d - c ) / magassag;
  double reC, imC, reZ, imZ;
  int iteracio = 0;

  std::cout << "Szamitas\n";

  // j megy a sorokon
  for ( int j = 0; j < magassag; ++j )
    {
      // k megy az oszlopokon

      for ( int k = 0; k < szelesseg; ++k )
        {

          // c = (reC, imC) a halo racspontjainak
          // megfelelo komplex szam

          reC = a + k * dx;
          imC = d - j * dy;
          std::complex<double> c ( reC, imC );

          std::complex<double> z_n ( 0, 0 );
          iteracio = 0;

          while ( std::abs ( z_n ) < 4 && iteracio < iteraciosHatar )
            {
              z_n = z_n * z_n + c;

              ++iteracio;
            }

          kep.set_pixel ( k, j,
                          png::rgb_pixel ( iteracio%255, (iteracio*iteracio)%255, 0 ) );
        }

      int szazalek = ( double ) j / ( double ) magassag * 100.0;
      std::cout << "\r" << szazalek << "%" << std::flush;
    }

  kep.write ( argv[1] );
  std::cout << "\r" << argv[1] << " mentve." << std::endl;

}
]]>
        </programlisting>
        <para>
            Ennek a programnak a működése nagyon hasonló az előzőhöz, így pár részlet fölött elsiklanék.
            Viszont ami kiemelendő, hogy itt már ki is van használva a C++ egyes előnyei a C-vel szemben. Első 
            sorban, hogy itt már meghívásra került a Complex library, mely segítségével egyszerűbben hozhatunk létre 
            komplex számokat, anélkül, hogy ehhez struktúrát kéne használnuk. A másik, hogy az abs() függvény segítségével 
            a négyzetre emelést is egyszerűbb megtenni, meg a végeredmény is könnyebben érthető, mint hogy változók 
            vannak  megszorozva önmagukkal. 
        </para>
    </section>        
                
    <section>
        <title>Biomorfok</title>
        <para>
        </para>
        <para>
            Megoldás videó: <link xlink:href="https://youtu.be/IJMbgRzY76E">https://youtu.be/IJMbgRzY76E</link>
        </para>
        <para>
            Megoldás forrása: <link xlink:href="https://gitlab.com/nbatfai/bhax/tree/master/attention_raising/Biomorf">https://gitlab.com/nbatfai/bhax/tree/master/attention_raising/Biomorf</link>
        </para>
        <para>
            A biomorfokra (a Julia halmazokat rajzoló bug-os programjával) 
            rátaláló Clifford Pickover azt hitte természeti törvényre 
            bukkant: <link xlink:href="https://www.emis.de/journals/TJNSA/includes/files/articles/Vol9_Iss5_2305--2315_Biomorphs_via_modified_iterations.pdf">https://www.emis.de/journals/TJNSA/includes/files/articles/Vol9_Iss5_2305--2315_Biomorphs_via_modified_iterations.pdf</link> (lásd a 2307. oldal aljától).
        </para>       
        <para>
            A különbség a <link xlink:href="#bhax-textbook-feladatok-mandelbrot.Mandelbrot">Mandelbrot halmaz</link>
            és a Julia halmazok között az, hogy a komplex iterációban az előbbiben a c változó, utóbbiban pedig állandó. 
            A következő Mandelbrot csipet azt mutatja, hogy a c befutja a vizsgált összes rácspontot.
        </para> 
        <para>
            Ezeket kiegészíteném azzokkal az érdekességekkel, hogy Julia halmazból végtelen sok van, melyeket magába 
            foglal a Mandelbrot halmaz, melyből viszont csak egy létezik. Továbbá fontos lehet megjegyezni, hogy a biomorfok 
            speciális Pickover szálak, melyek hasonlítanak biológiai alakzatokra, példáúl sejtekre. Innen is ered a biomorf 
            elnevezés. 
        </para>      
        <programlisting language="c++">
<![CDATA[  // j megy a sorokon
  for ( int j = 0; j < magassag; ++j )
    {
      for ( int k = 0; k < szelesseg; ++k )
        {

          // c = (reC, imC) a halo racspontjainak
          // megfelelo komplex szam

          reC = a + k * dx;
          imC = d - j * dy;
          std::complex<double> c ( reC, imC );

          std::complex<double> z_n ( 0, 0 );
          iteracio = 0;

          while ( std::abs ( z_n ) < 4 && iteracio < iteraciosHatar )
            {
              z_n = z_n * z_n + c;

              ++iteracio;
            }
]]>
        </programlisting>        
        <para>
            Ezzel szemben a Julia halmazos csipetben a cc nem változik, hanem minden vizsgált
            z rácspontra ugyanaz.
        </para>
        <programlisting language="c++">
<![CDATA[    // j megy a sorokon
    for ( int j = 0; j < magassag; ++j )
    {
        // k megy az oszlopokon
        for ( int k = 0; k < szelesseg; ++k )
        {
            double reZ = a + k * dx;
            double imZ = d - j * dy;
            std::complex<double> z_n ( reZ, imZ );

            int iteracio = 0;
            for (int i=0; i < iteraciosHatar; ++i)
            {
                z_n = std::pow(z_n, 3) + cc;
                if(std::real ( z_n ) > R || std::imag ( z_n ) > R)
                {
                    iteracio = i;
                    break;
                }
            }
]]>
        </programlisting>                         
        
        <para>
            A bimorfos algoritmus pontos megismeréséhez ezt a cikket javasoljuk: 
            <link xlink:href="https://www.emis.de/journals/TJNSA/includes/files/articles/Vol9_Iss5_2305--2315_Biomorphs_via_modified_iterations.pdf">https://www.emis.de/journals/TJNSA/includes/files/articles/Vol9_Iss5_2305--2315_Biomorphs_via_modified_iterations.pdf</link>.
            Az is jó gyakorlat, ha magából ebből a cikkből from scratch kódoljuk be a sajátunkat, de mi a királyi úton járva a 
            korábbi <link xlink:href="#bhax-textbook-feladatok-mandelbrot.Mandelbrot">Mandelbrot halmazt</link> kiszámoló 
            forrásunkat módosítjuk. Viszont a program változóinak elnevezését összhangba hozzuk a közlemény jelöléseivel:
        </para>       
        <programlisting language="c++">
<![CDATA[// Verzio: 3.1.3.cpp
// Forditas:
// g++ 3.1.3.cpp -lpng -O3 -o 3.1.3
// Futtatas:
// ./3.1.3 bmorf.png 800 800 10 -2 2 -2 2 .285 0 10
// Nyomtatas:
// a2ps 3.1.3.cpp -o 3.1.3.cpp.pdf -1 --line-numbers=1  --left-footer="BATF41 HAXOR STR34M" --right-footer="https://bhaxor.blog.hu/" --pro=color
// 
// BHAX Biomorphs
// Copyright (C) 2019
// Norbert Batfai, batfai.norbert@inf.unideb.hu
//
//  This program is free software: you can redistribute it and/or modify
//  it under the terms of the GNU General Public License as published by
//  the Free Software Foundation, either version 3 of the License, or
//  (at your option) any later version.
//
//  This program is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//  GNU General Public License for more details.
//
//  You should have received a copy of the GNU General Public License
//  along with this program.  If not, see <https://www.gnu.org/licenses/>.
//
// Version history
//
// https://youtu.be/IJMbgRzY76E
// See also https://www.emis.de/journals/TJNSA/includes/files/articles/Vol9_Iss5_2305--2315_Biomorphs_via_modified_iterations.pdf
//

#include <iostream>
#include "png++/png.hpp"
#include <complex>

int
main ( int argc, char *argv[] )
{

    int szelesseg = 1920;
    int magassag = 1080;
    int iteraciosHatar = 255;
    double xmin = -1.9;
    double xmax = 0.7;
    double ymin = -1.3;
    double ymax = 1.3;
    double reC = .285, imC = 0;
    double R = 10.0;

    if ( argc == 12 )
    {
        szelesseg = atoi ( argv[2] );
        magassag =  atoi ( argv[3] );
        iteraciosHatar =  atoi ( argv[4] );
        xmin = atof ( argv[5] );
        xmax = atof ( argv[6] );
        ymin = atof ( argv[7] );
        ymax = atof ( argv[8] );
        reC = atof ( argv[9] );
        imC = atof ( argv[10] );
        R = atof ( argv[11] );

    }
    else
    {
        std::cout << "Hasznalat: ./3.1.2 fajlnev szelesseg magassag n a b c d reC imC R" << std::endl;
        return -1;
    }

    png::image < png::rgb_pixel > kep ( szelesseg, magassag );

    double dx = ( xmax - xmin ) / szelesseg;
    double dy = ( ymax - ymin ) / magassag;

    std::complex<double> cc ( reC, imC );

    std::cout << "Szamitas\n";

    // j megy a sorokon
    for ( int y = 0; y < magassag; ++y )
    {
        // k megy az oszlopokon

        for ( int x = 0; x < szelesseg; ++x )
        {

            double reZ = xmin + x * dx;
            double imZ = ymax - y * dy;
            std::complex<double> z_n ( reZ, imZ );

            int iteracio = 0;
            for (int i=0; i < iteraciosHatar; ++i)
            {

                z_n = std::pow(z_n, 3) + cc;
                //z_n = std::pow(z_n, 2) + std::sin(z_n) + cc;
                if(std::real ( z_n ) > R || std::imag ( z_n ) > R)
                {
                    iteracio = i;
                    break;
                }
            }

            kep.set_pixel ( x, y,
                            png::rgb_pixel ( (iteracio*20)%255, (iteracio*40)%255, (iteracio*60)%255 ));
        }

        int szazalek = ( double ) y / ( double ) magassag * 100.0;
        std::cout << "\r" << szazalek << "%" << std::flush;
    }

    kep.write ( argv[1] );
    std::cout << "\r" << argv[1] << " mentve." << std::endl;

}
]]>
        </programlisting>                           
        <para>
            Itt is azt figyeljük, hogy mikor hagyja el a halmazt, de itt már kicsit színesítünk a dolgokon. 
        </para>  
        <para>
            Futtatás az eredeti értékekkel: 
        </para>  
        <mediaobject>
            <imageobject>
                <imagedata fileref="./Pics/Biomorf3.png" format="PNG" scale="25"/>
            </imageobject>
        </mediaobject>
        <para>
            Futtatás módosított értékekkel (1): 
        </para>  
        <mediaobject>
            <imageobject>
                <imagedata fileref="./Pics/Biomorf2.png" format="PNG" scale="25"/>
            </imageobject>
        </mediaobject>    
        <para>
            Futtatás módosított értékekkel (2): 
        </para>  
        <mediaobject>
            <imageobject>
                <imagedata fileref="./Pics/Biomorf1.png" format="PNG" scale="25"/>
            </imageobject>
        </mediaobject>                     
                                                                            
    </section>                     

    <section>
        <title>A Mandelbrot halmaz CUDA megvalósítása</title>
        <para>
        </para>
        <para>
            Megoldás videó: <link xlink:href="https://youtu.be/gvaqijHlRUs">https://youtu.be/gvaqijHlRUs</link>
        </para>
        <para>
            Megoldás forrása:                
 <link xlink:href="../../../bhax/attention_raising/CUDA/mandelpngc_60x60_100.cu">
                <filename>bhax/attention_raising/CUDA/mandelpngc_60x60_100.cu</filename>
            </link> nevű állománya.            
        </para>
        <para>
            Ez a feladat azt hivatott szemléltetni, hogy milyen előnyei lehetnek az Nvidia által fejlesztett 
            CUDA drivernek a grafikai megjelenítésben. A technológiát nagyon sokrétűen alkalmazzák, kezdve a 3D 
            grafikától (magam is használom a rendereltetéshez, mert jóval gyorsabban számól, mint a CPU) egészen a 
            játékokig. 
        </para>
        <para>
            Legnagyobb előnye a klasszikus OpenGL-el szemben, hogy nem a processzor használja a számításhoz, hanem a 
            videókártyát (fontos megjegyezni, hogy ez csak az nvidia viseókártyákra vonatkozik, az amd-sek itt hátrányban vannak)
            , azon belül is az úgynevezett CUDA magokat. Típustól függően eltérő számú mag található a VGA-ban, de minden esetben 
            több százról van szó. 
        </para>
        <para>
            Az alábbi példában kiosztjuk a generálni kívánt kép (vagy hívhatjuk renderelésnek is) pixeleit egy-egy 
            CUDA magnak és meglátjuk mi lesz. 
        </para>
        <para>
            Eddig ha le akartunk renderelni egy Mandelbrot halmazt, az hosszú másodpercekig is eltarthat (nyílván ez nem olyan 
            vészes, de egy komolyabb számítás esettén a szükséges idő is arányosan hatványozódik), míg a CUDA render esetén ez a 
            másodperc tört része csupán. De hogy történt ez? 
        </para>
        <para>
            Ahogy a római mondás is tartja: Divide et Impera (oszd meg és uralkodj).
            Ahelyett, hogy ezt a bonyolult feladatot pár darab processzor magra sózzuk (jelen esetben 4 magról van szó),
            inkább kiszervezzük párszáz CUDA magnak. Szerintem nem kell sokat magyaráznom, hogy mi a különbség. Közösen 
            pillanatok alatt végeznek a számítással és még csak kicsit se terhelik le a rendszer. 
            De ne csak a levegőbe beszéljünk, jöjjenek a számok: 
        </para>
        <screen>
            <![CDATA[ 
36
0.368979 sec
            ]]>
        </screen>
        <mediaobject>
            <imageobject>
                <imagedata fileref="Mandelbrot/CUDA/mandel.png" scale="50" />
            </imageobject>
            <textobject>
                <phrase>Cuda Mandelbrot</phrase>
            </textobject>
        </mediaobject>
        <para>
            Mint ahogy azt láthatjuk nagyon szépen lefutott, töredék idő alatt. Még itt megjegyeznék annyit, hogy kipróbáltam régebbi driverrel is, azzal nem sikerült, viszont a jelenegi 410.104-es 
            driver könnyű szerrel vette az akadályt. Egyébként a driver verzió egyszerűen lekérhető a következő paranccsal: 
        </para>
        <screen><![CDATA[ nvidia-smi]]></screen>
        <para>
            És valami ilyesmit kapunk: 
        </para>
        <screen>
<![CDATA[ 
Fri May 15 16:16:46 2020       
+-----------------------------------------------------------------------------+
| NVIDIA-SMI 410.104      Driver Version: 410.104      CUDA Version: 10.0     |
|-------------------------------+----------------------+----------------------+
| GPU  Name        Persistence-M| Bus-Id        Disp.A | Volatile Uncorr. ECC |
| Fan  Temp  Perf  Pwr:Usage/Cap|         Memory-Usage | GPU-Util  Compute M. |
|===============================+======================+======================|
|   0  GeForce 920M        Off  | 00000000:04:00.0 N/A |                  N/A |
| N/A   49C    P0    N/A /  N/A |    240MiB /  2004MiB |     N/A      Default |
+-------------------------------+----------------------+----------------------+
                                                                               
+-----------------------------------------------------------------------------+
| Processes:                                                       GPU Memory |
|  GPU       PID   Type   Process name                             Usage      |
|=============================================================================|
|    0                    Not Supported                                       |
+-----------------------------------------------------------------------------+
]]>
        </screen>
        <para>
            Látszik, hogy nem a legerősebb vas és a driverem se a legfrissebb. Viszont a driver frissítés kicsit veszélyes linuxon. Legutóbb mikor frissíteni próbáltam egy végtelen ciklusba kerül a 
            login-screen. Csak úgy sikerült bejutnom, hogy a boot beállításokat meghaxorkodtam, hogy videókártya nélkül induljon és letörölhessem azt a frissítést. Mondanom sem kell, hogy életem legjobb 
            két órája volt amíg rá nem találtam a megoldásra. Szóval óvatosan a Nvidia driver telepítéssel, legjobb ha van backupunk. 
        </para>
    </section>                     

    <section>
        <title>Mandelbrot nagyító és utazó C++ nyelven</title>
        <para>
            Építs GUI-t a Mandelbrot algoritmusra, lehessen egérrel nagyítani egy területet, illetve egy pontot
            egérrel kiválasztva vizualizálja onnan a komplex iteréció bejárta z<subscript>n</subscript> komplex számokat!
        </para>
        <para>
            Megoldás videó: <link xlink:href=""></link>
            Illetve <link xlink:href="https://bhaxor.blog.hu/2018/09/02/ismerkedes_a_mandelbrot_halmazzal">https://bhaxor.blog.hu/2018/09/02/ismerkedes_a_mandelbrot_halmazzal</link>.        </para>
        <para>
            Megoldás forrása: <link xlink:href=""></link>
        </para>
        <para>
            Ebben a feladatban az volt a lényeg, hogy a korábban használt Mandelbrot programunknak grafikus felhasználói 
            felületetet (Graphic User Interface - GUI) hozzunk létre. Ehhez segítségűl hívjuk a QT program könyvtárait és objektum 
            orientáltá alakítjuk a programunkat. 
        </para>
        <para>
            Létrehoztunk egy frakablak nevű programot, mely segítségével a terminál helyet már rendesen ablakban futtathtó a programunk, 
            melyben megjeleníthető a mandelbrot. A main-t nem részletezném, ott igazából csak a <varname>FrakAblak</varname> konstruktorhoz készítünk objektumot és megjelenítjük azt. 
            A <varname>FrakAblak</varname>-ot meg a <varname>FrakAblak</varname>-at viszont kifejteném kicsit jobban. Kezdjük az előbbivel: 
        </para>
        <programlisting language = "c++">
            <![CDATA[ 
#include <iostream>
    #include "frakablak.h"
    
    FrakAblak::FrakAblak(double a, double b, double c, double d,
                            int szelesseg, int iteraciosHatar, QWidget *parent)
                                : QMainWindow(parent)
    {
        setWindowTitle("Mandelbrot halmaz");
    
        szamitasFut = true;
        x = y = mx = my = 0;
        this->a = a;
        this->b = b;
        this->c = c;
        this->d = d;
        this->szelesseg = szelesseg;
        this->iteraciosHatar = iteraciosHatar;
        magassag = (int)(szelesseg * ((d-c)/(b-a)));
    
        setFixedSize(QSize(szelesseg, magassag));
        fraktal= new QImage(szelesseg, magassag, QImage::Format_RGB32);
    
        mandelbrot = new FrakSzal(a, b, c, d, szelesseg, magassag, iteraciosHatar, this);
        mandelbrot->start();
    }
    
    FrakAblak::~FrakAblak()
    {
        delete fraktal;
        delete mandelbrot;
    }
    
    void FrakAblak::paintEvent(QPaintEvent*) {
        QPainter qpainter(this);
        qpainter.drawImage(0, 0, *fraktal);
        if(!szamitasFut) {
            qpainter.setPen(QPen(Qt::white, 1));
            qpainter.drawRect(x, y, mx, my);
            if(!zX.empty()) //excuse me
            {
                for(int i=0; i<zX.size(); i++)
                {
                    qpainter.drawLine(zX[i],zY[i],zX2[i],zY2[i]);
                }
    
            }
    
    
        }
        qpainter.end();
    }
    
    void FrakAblak::mousePressEvent(QMouseEvent* event) {
    
        if(event->button() == Qt::LeftButton)
        {
        x = event->x();
        y = event->y();
        mx = 0;
        my = 0;
        }
        else if(event->button() == Qt::RightButton)
        {
                    double dx = (b-a)/szelesseg;
                    double dy = (d-c)/magassag;
                    double reC, imC, reZ, imZ, ujreZ, ujimZ;
    
                    int iteracio = 0;
    
                    reC = a+event->x()*dx;
                    imC = d-event->y()*dy;
    
                    reZ = 0;
                    imZ = 0;
                    iteracio = 0;
    
                    while(reZ*reZ + imZ*imZ < 4 && iteracio < 255) {
                        // z_{n+1} = z_n * z_n + c
                        ujreZ = reZ*reZ - imZ*imZ + reC;
                        ujimZ = 2*reZ*imZ + imC;
                        zX.push_back((int)((reZ - a)/dx));
                        zY.push_back( (int)((d - imZ)/dy));
                        zX2.push_back((int)((ujreZ - a)/dx));
                        zY2.push_back((int)((d - ujimZ)/dy));
                        reZ = ujreZ;
                        imZ = ujimZ;
    
                        ++iteracio;
        }
        }
        update();
    }
    
    void FrakAblak::mouseMoveEvent(QMouseEvent* event) {
    
        // A nagyítandó kijelölt terület szélessége és magassága:
        mx = event->x() - x;
        my = mx; // négyzet alakú
    
        update();
    }
    
    void FrakAblak::mouseReleaseEvent(QMouseEvent* event) {
    
        if(event->button() == Qt::LeftButton)
        {
        if(szamitasFut)
            return;
    
        szamitasFut = true;
    
        double dx = (b-a)/szelesseg;
        double dy = (d-c)/magassag;
    
        double a = this->a+x*dx;
        double b = this->a+x*dx+mx*dx;
        double c = this->d-y*dy-my*dy;
        double d = this->d-y*dy;
    
        this->a = a;
        this->b = b;
        this->c = c;
        this->d = d;
    
        delete mandelbrot;
        mandelbrot = new FrakSzal(a, b, c, d, szelesseg, magassag, iteraciosHatar, this);
        mandelbrot->start();
        }
        update();
    }
    
    void FrakAblak::keyPressEvent(QKeyEvent *event)
    {
    
        if(szamitasFut)
            return;
    
        if (event->key() == Qt::Key_N)
            iteraciosHatar *= 2;
        szamitasFut = true;
    
        delete mandelbrot;
        mandelbrot = new FrakSzal(a, b, c, d, szelesseg, magassag, iteraciosHatar, this);
        mandelbrot->start();
    
    }
    
    
    void FrakAblak::vissza(int magassag, int *sor, int meret)
    {
        int piros = 0;
        int zold = 0;
        int kek = 0;
    
        for(int i=0; i<meret; ++i) 
        {
    
            piros = 120 - sor[i];
            zold = 256 - sor[i];
            kek = 170 - sor[i];
    
            std::cout<< piros << " " << zold << " " << kek << " " << std::endl;
    
            QRgb szin = qRgb(piros, zold, kek); //qRgb(135, 255-sor[i], 180);//qRgb(piros, kek, zold); //qRgb(0, 255-sor[i], 0);    qRgb(105, 255-sor[i], 180);
            fraktal->setPixel(i, magassag, szin);
        }
        update();
    }
    
    void FrakAblak::vissza(void)
    {
        szamitasFut = false;
        x = y = mx = my = 0;
    }
            ]]>
        </programlisting>
        <para>
            Először is van egy (osztályon kívűl deklarált) konstruktorunk, mely létrehozza az ablakot, átadja a paramétereket és végül meghívja a <function>FrakSzal</function>-t. 
            Ezt követi a destruktor. Aztán jönnek a függvényeink. Az első a <function>paintEvent</function> amely a kirajzolásért felel, plusz a kijelöléskori vizalizálást (a kis 
            téglalap) és az újraszámításkor a pisor vonalat ami mutatja, hogy hol tart a számítás. Utánna jön az interaktivítás támogatása, azaz a nagyítás megvalósítására. Egy kijelölt 
            területbe akarunk belenagyítani, amit úgy érünk el, hogy újraszámoltatjuk a halmazt, viszont már csak azon a számsíkon ami a kijelölésbe beleesik. Ehhez vizsgálnunk kell az 
            egerünk 3 állapotát. Egész pontosan azt amikor lenyomjuk a gombot, azt amikor mozgatjuk és azt amikor elengedjuk. Ehhez a három fázishoz három beépített függvényt fogunk alkalmazni. 
            Az első a <function>mousePressEvent</function>, ami ahogy a neve is sugalja, az egér lenyomását figyeli. Itt csak bekérjük a kurzor aktuális x és y koordinátáit. Az x-et 
            átadjuk a <function>mouseMoveEvent</function>-nek aki a lekért új x-ből, kivonja az eredetit, így meghatározva a vízszintesen megtett távolságot, majd ezt átadja az <varname>my</varname>-nak 
            mivel négyzet alakú kijelölést szeretnénk, ezért a két oldal hossza megegyezik. Na de már van kiinduló pontunk, meg kijelölés kerülete, már csak egy végpont kéne, hogy az 
            új értékek segítségével újra számoltassuk az egészet. És pontosan ezt fogja tenni a <function>mouseReleaseEvent</function>.
            De nem csak az egérrel léphetünk interakcióba a programmal, van lehetőségünk az "n" billentyű lenyomásával is. Ebben segít nekünk a <function>keyPressEvent</function>, mely 
            hasonló az előbbiekhez, viszont ez billentyű leütést figyel. Amit csinál az nem más, mint, hogy az aktuális iterációs határt megduplázza és újraszámoltatja a halmazt, hogy 
            pontosabb eredményt kapjunk. A <function>vissza</function>-ból kettőnk is van. Amelyik paramétereket is kap az meghatározza az aktuális sornak a pixeleinek a színét. A paraméter 
            nélküli viszont csak már visszaállítja az értékeket alapértelmezetbe. 
        </para> 
        <para>
            Na most nézzük a <function>FrakSzal</function>-at ahol a munka folyik:  
        </para>
        <programlisting language="c++">
<![CDATA[ 
#include "frakszal.h"

FrakSzal::FrakSzal(double a, double b, double c, double d,
                   int szelesseg, int magassag, int iteraciosHatar, FrakAblak *frakAblak)
{
    this->a = a;
    this->b = b;
    this->c = c;
    this->d = d;
    this->szelesseg = szelesseg;
    this->iteraciosHatar = iteraciosHatar;
    this->frakAblak = frakAblak;
    this->magassag = magassag;

    egySor = new int[szelesseg];
}

FrakSzal::~FrakSzal()
{
    delete[] egySor;
}

void FrakSzal::run()
{
    // A [a,b]x[c,d] tartományon milyen sûrû a
    // megadott szélesség, magasság háló:
    double dx = (b-a)/szelesseg;
    double dy = (d-c)/magassag;
    double reC, imC, reZ, imZ, ujreZ, ujimZ;
    
    int iteracio = 0;
    
    for(int j=0; j<magassag; ++j) {
       
        for(int k=0; k<szelesseg; ++k) {
           
            reC = a+k*dx;
            imC = d-j*dy;
            
            reZ = 0;
            imZ = 0;
            iteracio = 0;
            
            while(reZ*reZ + imZ*imZ < 4 && iteracio < iteraciosHatar) {
                // z_{n+1} = z_n * z_n + c

                ujreZ = reZ*reZ - imZ*imZ + reC;
                ujimZ = 2*reZ*imZ + imC;

                reZ = ujreZ;
                imZ = ujimZ;

                ++iteracio;

            }

            iteracio %= 256;

           
            egySor[k] = iteracio;
        }
  
        frakAblak->vissza(j, egySor, szelesseg);
    }
    frakAblak->vissza();

}
]]>
        </programlisting>
        <para>
            A konstruktornak átadjuk az értékeket, meg elkészítünk egy <type>integer</type> tömböt. A destruktor csak ezt a tömböt fogja törölni. A lényeg viszont a <function>run</function>-ban 
            van. Ez a programunk szíve, lelke. Ez a motor ami az egész mögött áll: A matematikai számítások. A módszer és a megvalósítás lényegében ugyan az mint a többi változatban, tehát nem 
            ismételném meg, hogy kerüljem az önismétlést. Minden sor pixeljét eltároljuk az <varname>egySor</varname> tömb egy eleme ként, majd ezeket átadjuk soronként a <function>vissza</function> 
            függvénynek, hogy meghatározza sorban lévő pixelek színét. Végül ha az utolsó sor is megvolt akkor pedig meghívjuk a másik <function>vissza</function> függvényt, hogy visszaállítsuk az 
            értékeket nullára, így felkíszülve egy újabb számításra. 
        </para>
        <mediaobject>
            <imageobject>
                <imagedata fileref="./Pics/nagyito.png" format="PNG" scale="50"/>
            </imageobject>
        </mediaobject>
        <mediaobject>
            <imageobject>
                <imagedata fileref="./Pics/nagyito1.png" format="PNG" scale="50"/>
            </imageobject>
        </mediaobject>      
        <mediaobject>
            <imageobject>
                <imagedata fileref="./Pics/nagyito2.png" format="PNG" scale="50"/>
            </imageobject>
        </mediaobject>            
    </section>                     
                                                                                                                                                                            
    <section>
        <title>Mandelbrot nagyító és utazó Java nyelven</title>
        <para>
        </para>
        <para>
            Megoldás videó: <link xlink:href="https://youtu.be/Ui3B6IJnssY">https://youtu.be/Ui3B6IJnssY</link>, 4:27-től.
            Illetve <link xlink:href="https://bhaxor.blog.hu/2018/09/02/ismerkedes_a_mandelbrot_halmazzal">https://bhaxor.blog.hu/2018/09/02/ismerkedes_a_mandelbrot_halmazzal</link>.
        </para>
        <para>
            Megoldás forrása: <link xlink:href="https://www.tankonyvtar.hu/hu/tartalom/tkt/javat-tanitok-javat/apbs02.html#id570518">https://www.tankonyvtar.hu/hu/tartalom/tkt/javat-tanitok-javat/apbs02.html#id570518</link>
        </para>
        <para>
            Az előző feladat java átírata. Ennek fordításához és futtatásához szükséges rendelkezni 
            az openjdk8-as csomaggal. 
        </para>
        <para>
            A telepítés: 
        </para>
        <screen>
            <![CDATA[
            sudo apt-get install openjdk-8-jdk  
            ]]>
        </screen>
        <para>A következő program Bátfai Norbert munkájának egy általam kiegészített változata (Nagyító):  </para>
        <programlisting language = "java">
            <![CDATA[ 
import java.awt.*;
/*
    * MandelbrotHalmaz.java
    *
    * DIGIT 2005, Javat tanítok
    * Bátfai Norbert, nbatfai@inf.unideb.hu
    *
    */
/**
    * A Mandelbrot halmazt kiszámoló és kirajzoló osztály.
    * A programot módosította/kiegészítette: Czanik András
    *
    * @author Bátfai Norbert, nbatfai@inf.unideb.hu
    * @version 0.0.1
    */
public class MandelbrotZoom extends java.awt.Frame implements Runnable {

    protected double a, b, c, d;
    protected int szélesség, magasság;
    protected java.awt.image.BufferedImage kép;
    protected int iterációsHatár = 255;
    protected boolean számításFut = false;
    protected int sor = 0;
    protected static int pillanatfelvételSzámláló = 0;

    public static int x;
    public static int y;
    public static int mx;
    public static int my;

    public MandelbrotZoom(double a, double b, double c, double d,
            int szélesség, int iterációsHatár) {
        this.a = a;
        this.b = b;
        this.c = c;
        this.d = d;
        this.szélesség = szélesség;
        this.iterációsHatár = iterációsHatár;
        this.magasság = (int)(szélesség * ((d-c)/(b-a)));
        kép = new java.awt.image.BufferedImage(szélesség, magasság,
                java.awt.image.BufferedImage.TYPE_INT_RGB);
        addWindowListener(new java.awt.event.WindowAdapter() {
            public void windowClosing(java.awt.event.WindowEvent e) {
                setVisible(false);
                System.exit(0);
            }
        });
        addKeyListener(new java.awt.event.KeyAdapter() {
            public void keyPressed(java.awt.event.KeyEvent e) {
                if(e.getKeyCode() == java.awt.event.KeyEvent.VK_S)
                    pillanatfelvétel();

                else if(e.getKeyCode() == java.awt.event.KeyEvent.VK_N) {
                    if(számításFut == false) {
                        MandelbrotZoom.this.iterációsHatár += 256;

                        számításFut = true;
                        new Thread(MandelbrotZoom.this).start();
                    }

                } else if(e.getKeyCode() == java.awt.event.KeyEvent.VK_M) {
                    if(számításFut == false) {
                        MandelbrotZoom.this.iterációsHatár += 10*256;

                        számításFut = true;
                        new Thread(MandelbrotZoom.this).start();
                    }
                }
            }
        });
        addMouseListener(new java.awt.event.MouseAdapter() {
            @Override
            public void mousePressed(java.awt.event.MouseEvent me) {
                x = me.getX();
                y = me.getY();
            }

            @Override
            public void mouseReleased(java.awt.event.MouseEvent me) {
                számításFut = true;
                
                double dx = (b - a) / szélesség;
                double dy = (d - c) / magasság;

                double range = 60;

                double a = MandelbrotZoom.this.a+x*dx;
                double b = MandelbrotZoom.this.a+x*dx+range*dx;
                double c = MandelbrotZoom.this.d-y*dy-range*dy;
                double d = MandelbrotZoom.this.d-y*dy;

                MandelbrotZoom.this.a = a; 
                MandelbrotZoom.this.b = b; 
                MandelbrotZoom.this.c = c; 
                MandelbrotZoom.this.d = d; 

                new Thread(MandelbrotZoom.this).start();
            }
        });
        addMouseMotionListener(new java.awt.event.MouseMotionAdapter() {

            @Override
            public void mouseMoved(java.awt.event.MouseEvent me) {
                int mx = me.getX() - x;
                int my = mx;

                repaint();
            }
        });

        setTitle("A Mandelbrot halmaz");
        setResizable(false);
        setSize(szélesség, magasság);
        setVisible(true);

        számításFut = true;
        new Thread(this).start();
    }

    public void paint(java.awt.Graphics g) {
        g.drawImage(kép, 0, 0, this);
        if(számításFut) {
            g.setColor(java.awt.Color.RED);
            g.drawLine(0, sor, getWidth(), sor);
        }
    }

    public void update(java.awt.Graphics g) {
        paint(g);
    }

    public void pillanatfelvétel() {
        java.awt.image.BufferedImage mentKép =
                new java.awt.image.BufferedImage(szélesség, magasság,
                java.awt.image.BufferedImage.TYPE_INT_RGB);
        java.awt.Graphics g = mentKép.getGraphics();
        g.drawImage(kép, 0, 0, this);
        g.setColor(java.awt.Color.BLUE);
        g.drawString("a=" + a, 10, 15);
        g.drawString("b=" + b, 10, 30);
        g.drawString("c=" + c, 10, 45);
        g.drawString("d=" + d, 10, 60);
        g.drawString("n=" + iterációsHatár, 10, 75);
        g.dispose();

        StringBuffer sb = new StringBuffer();
        sb = sb.delete(0, sb.length());
        sb.append("MandelbrotZoom_");
        sb.append(++pillanatfelvételSzámláló);
        sb.append("_");
        sb.append(a);
        sb.append("_");
        sb.append(b);
        sb.append("_");
        sb.append(c);
        sb.append("_");
        sb.append(d);
        sb.append(".png");

        try {
            javax.imageio.ImageIO.write(mentKép, "png",
                    new java.io.File(sb.toString()));
        } catch(java.io.IOException e) {
            e.printStackTrace();
        }
    }


    
        public void run() {

        double dx = (b-a)/szélesség;
        double dy = (d-c)/magasság;
        double reC, imC, reZ, imZ, ujreZ, ujimZ;
        int rgb;
        int iteráció = 0;

        for(int j=0; j<magasság; ++j) {
            sor = j;
            for(int k=0; k<szélesség; ++k) {
                reC = a+k*dx;
                imC = d-j*dy;
                reZ = 0;
                imZ = 0;
                iteráció = 0;

                while(reZ*reZ + imZ*imZ < 4 && iteráció < iterációsHatár) {
                    ujreZ = reZ*reZ - imZ*imZ + reC;
                    ujimZ = 2*reZ*imZ + imC;
                    reZ = ujreZ;
                    imZ = ujimZ;
                    
                    ++iteráció;
                    
                }
                iteráció %= 256;
                rgb = (255-iteráció)|
                        ((255-iteráció) << 8) |
                        ((255-iteráció) << 16);
                kép.setRGB(k, j, rgb);
            }
            repaint();
        }
        számításFut = false;
    }
    public static void main(String[] args) {
        new MandelbrotZoom(-2.0, .7, -1.35, 1.35, 600, 255);
    }
}                
                
        
            ]]>
        </programlisting>
        <para>
            Daraboljuk fel és nézzük meg a függvényeket részenként. Itt már a kommenteket és a licenset kihagyom helytakarékosság célján: 
        </para>
        <programlisting language = "java">
            <![CDATA[ 
public class MandelbrotHalmaz extends java.awt.Frame implements Runnable {
    protected double a, b, c, d;
    protected int szélesség, magasság;
    protected java.awt.image.BufferedImage kép;
    protected int iterációsHatár = 255;
    protected boolean számításFut = false;
    protected int sor = 0;
    protected static int pillanatfelvételSzámláló = 0;
}
    ]]>
        </programlisting>
        <para>
            Itt még nagy csoda nem történik. Az osztályon belül létrehozzuk a szükséges változókat. 
        </para>
        <programlisting language = "java">
            <![CDATA[ 
public MandelbrotHalmaz(double a, double b, double c, double d,
        int szélesség, int iterációsHatár) {
    this.a = a;
    this.b = b;
    this.c = c;
    this.d = d;
    this.szélesség = szélesség;
    this.iterációsHatár = iterációsHatár;
    this.magasság = (int)(szélesség * ((d-c)/(b-a)));
    kép = new java.awt.image.BufferedImage(szélesség, magasság,
            java.awt.image.BufferedImage.TYPE_INT_RGB);

    addWindowListener(new java.awt.event.WindowAdapter() {
        public void windowClosing(java.awt.event.WindowEvent e) {
            setVisible(false);
            System.exit(0);
        }
    });

    addKeyListener(new java.awt.event.KeyAdapter() {
        public void keyPressed(java.awt.event.KeyEvent e) {
            if(e.getKeyCode() == java.awt.event.KeyEvent.VK_S)
                pillanatfelvétel();

            else if(e.getKeyCode() == java.awt.event.KeyEvent.VK_N) {
                if(számításFut == false) {
                    MandelbrotHalmaz.this.iterációsHatár += 256;
                    számításFut = true;
                    new Thread(MandelbrotHalmaz.this).start();
                }

            } else if(e.getKeyCode() == java.awt.event.KeyEvent.VK_M) {
                if(számításFut == false) {
                    MandelbrotHalmaz.this.iterációsHatár += 10*256;
                    számításFut = true;
                    new Thread(MandelbrotHalmaz.this).start();
                }
            }
        }
    });
    setTitle("A Mandelbrot halmaz");
    setResizable(false);
    setSize(szélesség, magasság);
    setVisible(true);
    számításFut = true;
    new Thread(this).start();
}
    ]]>
        </programlisting>
        <para>
            Az első függvényünk egyből maga fő függvény. A változóknak átadjuk a paraméterként kapott értékeket, a <varname>magassag</varname> esetén kiszámoljuk azt. Az <function>addWindowListener</function>-ben 
            létrehozzuk a <function>windowClosing</function> függvényt ami egyszerűen csak az ablak bezárásáért felel. Ezután jön egy kicsit érdekesebb rész a <function>addKeyListener</function>-ben, ahol 
            konkrétan billenytűket fogunk figyelni hogy különböző utasításokat hajtsunk végre. Ha megnyomjuk az "s"-t azzal meghívjuk a <function>pillanatfelvétel</function>-t ami screenshotot készít majd a halmazról. 
            Amikor az "n" gombot ütjük le, akkor az iterációs határt megnöveljük 256-al és újraszámoltatjuk a halmazt egy pontosabb eredményért. Hasonlóan jár el az "m" billenytű is, azzal a különbséggel, 
            hogy itt nem 256-al növelünk, hanem a 2560-al, azaz a tízszeresével. Végül pedig beállítjuk az ablak tulajdonságait, úgyis mint a címét, megtiltjuk az átméretezést, meghatározzuk a méretet és láthatóvá 
            tesszük (ez utóbbi tulajdonságát megvonjuk a bezárás előtt). 
        </para>
        <programlisting language = "java">
            <![CDATA[ 
addMouseListener(new java.awt.event.MouseAdapter() {
    @Override
    public void mousePressed(java.awt.event.MouseEvent me) {
        x = me.getX();
        y = me.getY();
    }

    @Override
    public void mouseReleased(java.awt.event.MouseEvent me) {
        számításFut = true;
        
        double dx = (b - a) / szélesség;
        double dy = (d - c) / magasság;

        double range = 60;

        double a = MandelbrotZoom.this.a+x*dx;
        double b = MandelbrotZoom.this.a+x*dx+range*dx;
        double c = MandelbrotZoom.this.d-y*dy-range*dy;
        double d = MandelbrotZoom.this.d-y*dy;

        MandelbrotZoom.this.a = a; 
        MandelbrotZoom.this.b = b; 
        MandelbrotZoom.this.c = c; 
        MandelbrotZoom.this.d = d; 

        new Thread(MandelbrotZoom.this).start();
    }
});
addMouseMotionListener(new java.awt.event.MouseMotionAdapter() {

    @Override
    public void mouseMoved(java.awt.event.MouseEvent me) {
        int mx = me.getX() - x;
        int my = mx;

        repaint();
    }
});
            ]]>
        </programlisting>
        <para>
            Ezt a részt külön venném, azon egyszerű okból, hogy ez az én hozzáaadott értékem a programhoz. Az eredeti verzió sajnos nem tudott nagyítani, ami a feladat kritériuma is. 
            Pont ezért ebben a rövid részletben megoldottam ezt, hogy az egérrel kijelölt területbe zoomoljunk bele. Az elv egy az egyben ugyan az mint a C++ verzióban. Tehát bekérjük 
            az egér pozícióját mikor lenyomjuk és mikor elengedjük. Közben mikör mozog az egér, a <varname>my</varname> és <varname>mx</varname>-ben eltároljuk az így kijelölt négyzet fő 
            pontjait, majd felengedéskor ezeket átadjuk a konstruktornak, hogy ezalapján legyen szíves újraszámolni a halmazt. 
        </para>
        <programlisting language = "java">
            <![CDATA[ 
public void paint(java.awt.Graphics g) {
    g.drawImage(kép, 0, 0, this);
    if(számításFut) {
        g.setColor(java.awt.Color.RED);
        g.drawLine(0, sor, getWidth(), sor);
    }
}

public void update(java.awt.Graphics g) {
    paint(g);
}

public void pillanatfelvétel() {
    java.awt.image.BufferedImage mentKép =
            new java.awt.image.BufferedImage(szélesség, magasság,
            java.awt.image.BufferedImage.TYPE_INT_RGB);
    java.awt.Graphics g = mentKép.getGraphics();
    g.drawImage(kép, 0, 0, this);
    g.setColor(java.awt.Color.BLUE);
    g.drawString("a=" + a, 10, 15);
    g.drawString("b=" + b, 10, 30);
    g.drawString("c=" + c, 10, 45);
    g.drawString("d=" + d, 10, 60);
    g.drawString("n=" + iterációsHatár, 10, 75);
    g.dispose();

    StringBuffer sb = new StringBuffer();
    sb = sb.delete(0, sb.length());
    sb.append("MandelbrotHalmaz_");
    sb.append(++pillanatfelvételSzámláló);
    sb.append("_");

    sb.append(a);
    sb.append("_");
    sb.append(b);
    sb.append("_");
    sb.append(c);
    sb.append("_");
    sb.append(d);
    sb.append(".png");

    try {
        javax.imageio.ImageIO.write(mentKép, "png",
                new java.io.File(sb.toString()));
    } catch(java.io.IOException e) {
        e.printStackTrace();
    }
}
    ]]>
        </programlisting>
        <para>
            A következő szakasz három függvényt tartalmaz. Az első a <function>paint</function> Ő felel azért hogy a mandelbrot halmaz meg is jelenjen a képernyőkön. Másik extra feature, hogy 
            ha újra számoltatjuk a halmazt esetlegesen egy nagyobb iterációban, akkor kirajzoltatunk vele egy piros vonalat, ami abban a sorban fog elhelyezkedni, ahol a számítás is tart. Semmi ördöngősség, 
            csak egy kis apróság, mely sokat dob a program megjelenésén és segít vizualizálni, hogy hol tart az újraszámítás. 
            Ezt követi az <function>update</function>, mely egyszerűen csak folyamatosan meghívja a <function>paint</function>-et, azaz frissíti a halmazunk állapotát, ahogy a neve is sugalja. 
            Végül pedig a <function>pillanatkep</function>. Az előző bekezdésben említettem, hogy ezzel szeretnénk screenshot-okat kimenteni png formátumba. Ez elsőre bonyultan hangozhat, de nem olyan vészes. 
            Létrehozunk egy új pufferelt képet, kirajzoltatjuk a képet, majd rá kékkel az iteráció szempontjából fontosabb változókat. Ha a kép megvan, akkor már csak el kéne nevezni valahogy. Ehhez kell 
            egy új <type>StringBuffer</type> amiben ezt tároljuk. Ez tartalmazza a nevét, a kép sorszámát, a fontosabb változókat (a, b, c és d), majd végül ugye a kiterjesztést. Ezt mind szépen összefűzzük. 
            És már adjuk is át a javax.imageio.ImageIO.write(mentKép, "png", new java.io.File(sb.toString()));-nak hogy elkészítse magát a képet. 
        </para>
        <programlisting language = "java">
            <![CDATA[ 
public void run() {
    double dx = (b-a)/szélesség;
    double dy = (d-c)/magasság;
    double reC, imC, reZ, imZ, ujreZ, ujimZ;
    int rgb;
    int iteráció = 0;
    for(int j=0; j<magasság; ++j) {
        sor = j;
        for(int k=0; k<szélesség; ++k) {
            reC = a+k*dx;
            imC = d-j*dy;
            reZ = 0;
            imZ = 0;
            iteráció = 0;
            while(reZ*reZ + imZ*imZ < 4 && iteráció < iterációsHatár) {

                ujreZ = reZ*reZ - imZ*imZ + reC;
                ujimZ = 2*reZ*imZ + imC;
                reZ = ujreZ;
                imZ = ujimZ;
                
                ++iteráció;
                
            }
            iteráció %= 256;
            rgb = (255-iteráció)|
                    ((255-iteráció) << 8) |
                    ((255-iteráció) << 16);
            kép.setRGB(k, j, rgb);
        }
        repaint();
    }
    számításFut = false;
}

public static void main(String[] args) {
    new MandelbrotHalmaz(-2.0, .7, -1.35, 1.35, 600, 255);
}
    ]]>
        </programlisting>
        <para>
            Végül pedig itt a lényeg, a <function>run</function>, ahol a varázslat végbemegy. Felvesszük a szükséges változókat, köztük a komplex számoknak is. Aztán jön egy klasszikus 
             sorfolytonos mátrix bejárás, hogy képünk minden pixelét meghatározzuk. Itt már a felvett változókból elkészítjük a valódi komplex számainkat és utánna megvizsgáljuk, hogy hány iteráció 
             alatt sikerül elhagynia a halmazt, ha sikerül persze. Az elv ugyan az mint a korábbi verzióknál, ezt nem részletezném különösebben.   Majd azalapján hogy ez mennyi időbe telt neki, 
             kap egy szín értéket. Soronként újrahívjuk a <function>repaint</function> függvényt, hogy nyomonkövethető legyen a folyamat, majd ha az utolsóval is végzett, akkor egyszerűen hamisra 
             állítjuk a <varname>számításFut</varname>-ot ezzel jelezvén más függvényeknek, hogy végeztünk. Végül pedig a <function>void</function> ami egyszerűen csak megfelelően felparaméterezve meghívja 
             a <function>MandelbrotHalmaz</function>-t.  
        </para>
        <para>
            Fordítás és futtatás: 
        </para>
        <screen>
            <![CDATA[
            javac MandelbrotHalmaz.java
            java MandelbrotHalmaz
            ]]>
        </screen>
        <mediaobject>
            <imageobject>
                <imagedata fileref="./Pics/MandelbrotZoom_1_-20_07_-135_135.png" format="PNG" scale="50"/>
            </imageobject>
        </mediaobject>
        <mediaobject>
            <imageobject>
                <imagedata fileref="./Pics/MandelbrotZoom_2_-07264999999999999_-04564999999999999_05085_07785.png" format="PNG" scale="50"/>
            </imageobject>
        </mediaobject>
    </section>
    <section>
        <title>Malmo: láváig fel, majd vissza le</title>
        <para>
            <link xlink:href="https://youtu.be/zO6cNp8L4-Q">https://youtu.be/zO6cNp8L4-Q</link>
        </para>
        <para>
            Ennél a feladatnál Stevenek fel kellett szaladnia a pályán hogy megközelítse a lávát annyira amennyire csak lehet. Azután 
            pedig forduljon meg és szedjen annyi virágot amennyit csak tud mielőtt utoléri a végzet narancssárga lávája. 
        </para>
        <programlisting language="python">
<![CDATA[ 
from __future__ import print_function
# ------------------------------------------------------------------------------------------------
# Copyright (c) 2016 Microsoft Corporation
# 
# Permission is hereby granted, free of charge, to any person obtaining a copy of this software and
# associated documentation files (the "Software"), to deal in the Software without restriction,
# including without limitation the rights to use, copy, modify, merge, publish, distribute,
# sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
# 
# The above copyright notice and this permission notice shall be included in all copies or
# substantial portions of the Software.
# 
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT
# NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
# DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
# ------------------------------------------------------------------------------------------------

# Tutorial sample #2: Run simple mission using raw XML

# Added modifications by Norbert Bátfai (nb4tf4i) batfai.norbert@inf.unideb.hu, mine.ly/nb4tf4i.1
# 2018.10.18, https://bhaxor.blog.hu/2018/10/18/malmo_minecraft
# 2020.02.02, NB4tf4i's Red Flowers, http://smartcity.inf.unideb.hu/~norbi/NB4tf4iRedFlowerHell


from builtins import range
import MalmoPython
import os
import sys
import time
import random
import json
import math

if sys.version_info[0] == 2:
    sys.stdout = os.fdopen(sys.stdout.fileno(), 'w', 0)  # flush print output immediately
else:
    import functools
    print = functools.partial(print, flush=True)

# Create default Malmo objects:

agent_host = MalmoPython.AgentHost()
try:
    agent_host.parse( sys.argv )
except RuntimeError as e:
    print('ERROR:',e)
    print(agent_host.getUsage())
    exit(1)
if agent_host.receivedArgument("help"):
    print(agent_host.getUsage())
    exit(0)

# -- set up the mission -- #
missionXML_file='nb4tf4i_d.xml'
with open(missionXML_file, 'r') as f:
    print("NB4tf4i's Red Flowers (Red Flower Hell) - DEAC-Hackers Battle Royale Arena\n")
    print("NB4tf4i vörös pipacsai (Vörös Pipacs Pokol) - DEAC-Hackers Battle Royale Arena\n\n")
    print("The aim of this first challenge, called nb4tf4i's red flowers, is to collect as many red flowers as possible before the lava flows down the hillside.\n")
    print("Ennek az első, az nb4tf4i vörös virágai nevű kihívásnak a célja összegyűjteni annyi piros virágot, amennyit csak lehet, mielőtt a láva lefolyik a hegyoldalon.\n")    
    print("Norbert Bátfai, batfai.norbert@inf.unideb.hu, https://arato.inf.unideb.hu/batfai.norbert/\n\n")    
    print("Loading mission from %s" % missionXML_file)
    mission_xml = f.read()
    my_mission = MalmoPython.MissionSpec(mission_xml, True)
    my_mission.drawBlock( 0, 0, 0, "lava")


class Hourglass:
    def __init__(self, charSet):
        self.charSet = charSet
        self.index = 0
    def cursor(self):
        self.index=(self.index+1)%len(self.charSet)
        return self.charSet[self.index]

hg = Hourglass('|/-\|')

class Steve:
    def __init__(self, agent_host):
        self.agent_host = agent_host
        self.x = 0
        self.y = 0
        self.z = 0        
        self.yaw = 0
        self.pitch = 0
        self.lookingat = 0     
        
    def run(self):
        world_state = self.agent_host.getWorldState()
        # Loop until mission ends:
        j = 1
        i = 3
        
        escape = 0
        move = 13
        ended = 0
        poppy = 0
         
        self.agent_host.sendCommand( "turn -1" )
        time.sleep(1)
        for i in range(4):
            self.agent_host.sendCommand( "move 1" )
            time.sleep(0.1)
        self.agent_host.sendCommand( "look 1" )
        self.agent_host.sendCommand( "move 0" )
        time.sleep(.5)
        self.agent_host.sendCommand( "attack 1" )
        time.sleep(1)
        self.agent_host.sendCommand( "look -1" )
        self.agent_host.sendCommand( "move 1" )
        time.sleep(0.1)
        self.agent_host.sendCommand( "jumpmove 1" )
        time.sleep(0.5)
        self.agent_host.sendCommand( "move 1" )
        time.sleep(0.1)
        #self.agent_host.sendCommand( "look -.2" )

        while world_state.is_mission_running:

            
            print("--- nb4tf4i arena -----------------------------------\n")

        
                    
            if world_state.number_of_observations_since_last_state != 0:
                            
                sensations = world_state.observations[-1].text
                print("    sensations: ", sensations)                
                observations = json.loads(sensations)
                nbr5x5x5 = observations.get("nbr5x5", 0)
                print("    5x5x5 neighborhood of Steve: ", nbr5x5x5)
                            
                if "Yaw" in observations:
                    self.yaw = int(observations["Yaw"])
                if "Pitch" in observations:
                    self.pitch = int(observations["Pitch"])
                if "XPos" in observations:
                    self.x = int(observations["XPos"])
                if "ZPos" in observations:
                    self.z = int(observations["ZPos"])        
                if "YPos" in observations:
                    self.y = int(observations["YPos"])  
                            
                print("    Steve's Coords: ", self.x, self.y, self.z)        
                print("    Steve's Yaw: ", self.yaw)        
                print("    Steve's Pitch: ", self.pitch)

                if "LineOfSight" in observations:
                    LineOfSight = observations["LineOfSight"]
                    self.lookingat = LineOfSight["type"]
                    print("    Steve's <): ", self.lookingat)

                
                #itt van a lényeg amúgy, az első felugrásig a while ciklus előtt van külön megirva
                    
                #if self.lookingat == "flowing_lava": #itt talalkozik a viraggal meg fel is veszi
            
                for i in range(125):
                    if nbr5x5x5[i] == "flowing_lava" or nbr5x5x5[i] == "lava":
                        print("     Lavaaaa!")
                        if escape == 0:
                            self.agent_host.sendCommand( "turn -1" )
                            time.sleep(0.01)
                            self.agent_host.sendCommand( "turn -1" )
                            time.sleep(0.01)
                        escape = 1 #ez az escape igaz hamis hogy kell-e menekülni, akkor már nem ugrik csak fut meg ne forogjon 
                    
                self.agent_host.sendCommand( "move 1" )
                time.sleep(0.01)
                self.agent_host.sendCommand( "move 1" )
                time.sleep(0.01)
                if escape == 0:
                    self.agent_host.sendCommand( "jumpmove 1" )
                    time.sleep(0.5)
                    
                    
            world_state = self.agent_host.getWorldState()
            if self.y < 7 and escape == 1:
                poppy = 1

            if poppy == 1: 
                for i in range(4):
                    self.agent_host.sendCommand( "turn 1" )
                    time.sleep(.1)
                    for j in range(move):
                        
                        if world_state.number_of_observations_since_last_state != 0:
                                
                            sensations = world_state.observations[-1].text
                            print("    sensations: ", sensations)                
                            observations = json.loads(sensations)
                            nbr3x3x3 = observations.get("nbr3x3", 0)
                            print("    3x3x3 neighborhood of Steve: ", nbr3x3x3)
                                
                            if "Yaw" in observations:
                                self.yaw = int(observations["Yaw"])
                            if "Pitch" in observations:
                                self.pitch = int(observations["Pitch"])
                            if "XPos" in observations:
                                self.x = int(observations["XPos"])
                            if "ZPos" in observations:
                                self.z = int(observations["ZPos"])        
                            if "YPos" in observations:
                                self.y = int(observations["YPos"])  
                                
                            print("    Steve's Coords: ", self.x, self.y, self.z)        
                            print("    Steve's Yaw: ", self.yaw)        
                            print("    Steve's Pitch: ", self.pitch)

                            if "LineOfSight" in observations:
                                LineOfSight = observations["LineOfSight"]
                                self.lookingat = LineOfSight["type"]
                            print("    Steve's <): ", self.lookingat)

                
                        

                            if nbr3x3x3[12] == "red_flower" or nbr3x3x3[13] == "red_flower" or nbr3x3x3[14] == "red_flower":
                                if nbr3x3x3[13] == "red_flower":
                                    self.agent_host.sendCommand( "move -1" )
                                    time.sleep(.1) #.5
                                if nbr3x3x3[14] == "red_flower":
                                    self.agent_host.sendCommand( "move 0" )
                                time.sleep(.5) #.5
                                self.agent_host.sendCommand( "look 1" )
                                #self.agent_host.sendCommand( "look .5" )
                                self.agent_host.sendCommand( "move 0" )
                                time.sleep(.5) #.5
                                self.agent_host.sendCommand( "attack 1" )
                                time.sleep(.5) #1
                                self.agent_host.sendCommand( "look -.5" )
                                #self.agent_host.sendCommand( "look -1" )
                                self.agent_host.sendCommand( "jumpmove 1" )
                                time.sleep(0.5)
                            

                        world_state = self.agent_host.getWorldState()
                        '''
                        if self.lookingat == "red_flower": #itt talalkozik a viraggal meg fel is veszi
                            print("     VIRAAAG!")
                            self.agent_host.sendCommand( "move 1" )
                            time.sleep(.5)
                            self.agent_host.sendCommand( "look 1" )
                            self.agent_host.sendCommand( "move 0" )
                            time.sleep(1.5)
                            self.agent_host.sendCommand( "attack 1" )
                            time.sleep(1.5)
                            self.agent_host.sendCommand( "look -1" )
                            self.agent_host.sendCommand( "jumpmove 1" )
                            time.sleep(1)
                        '''
                        #innen kezdodik a mozgasa
                        self.agent_host.sendCommand( "move 1" )
                        time.sleep(0.1)

                    world_state = self.agent_host.getWorldState()

                self.agent_host.sendCommand( "jumpmove 1" )
                time.sleep(0.5)
                self.agent_host.sendCommand( "move 1" )
                time.sleep(0.1)
                move = move + 4 



            


num_repeats = 1
for ii in range(num_repeats):

    my_mission_record = MalmoPython.MissionRecordSpec()

    # Attempt to start a mission:
    max_retries = 6
    for retry in range(max_retries):
        try:
            agent_host.startMission( my_mission, my_mission_record )
            break
        except RuntimeError as e:
            if retry == max_retries - 1:
                print("Error starting mission:", e)
                exit(1)
            else:
                print("Attempting to start the mission:")
                time.sleep(2)

    # Loop until mission starts:
    print("   Waiting for the mission to start ")
    world_state = agent_host.getWorldState()

    while not world_state.has_mission_begun:
        print("\r"+hg.cursor(), end="")
        time.sleep(0.15)
        world_state = agent_host.getWorldState()
        for error in world_state.errors:
            print("Error:",error.text)

    print("NB4tf4i Red Flower Hell running\n")
    steve = Steve(agent_host)
    steve.run()

print("Mission ended")
# Mission has ended.
]]>
        </programlisting>
    </section>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        
</chapter>                
