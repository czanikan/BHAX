<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <info>
        <title>Helló, Mandelbrot!</title>
        <keywordset>
            <keyword/>
        </keywordset>
    </info>
    <section xml:id="bhax-textbook-feladatok-mandelbrot.Mandelbrot">
        <title>A Mandelbrot halmaz</title>
        <para>
            Írj olyan C programot, amely kiszámolja a Mandelbrot halmazt!     
        </para>
        <para>
            Megoldás videó: <link xlink:href="https://youtu.be/gvaqijHlRUs">https://youtu.be/gvaqijHlRUs</link>
        </para>
        <para>
            Megoldás forrása:                
 <link xlink:href="../../../bhax/attention_raising/CUDA/mandelpngt.c++">
                <filename>bhax/attention_raising/CUDA/mandelpngt.c++</filename>
            </link> nevű állománya.            
        </para>
                <figure>
            <title>A Mandelbrot halmaz a komplex síkon</title>
            <mediaobject>
                <imageobject>
                    <imagedata fileref="img/mandel.png" scale="50" />
                </imageobject>
                <textobject>
                    <phrase>A Mandelbrot halmaz a komplex síkon</phrase>
                </textobject>
            </mediaobject>
        </figure>
        <para>
            A Mandelbrot halmazt 1980-ban találta meg Benoit Mandelbrot a 
            komplex számsíkon. Komplex számok azok a számok, amelyek körében 
            válaszolni lehet az olyan egyébként értelmezhetetlen kérdésekre, 
            hogy melyik az a két szám, amelyet összeszorozva -9-et kapunk, 
            mert ez a szám például a 3i komplex szám.
        </para>
        <para>             
            A Mandelbrot halmazt úgy láthatjuk meg, hogy a sík origója középpontú 4 
            oldalhosszúságú négyzetbe lefektetünk egy, mondjuk 800x800-as 
            rácsot és kiszámoljuk, hogy a rács pontjai mely komplex számoknak 
            felelnek meg. A rács minden pontját megvizsgáljuk a 
            z<subscript>n+1</subscript>=z<subscript>n</subscript>
            <superscript>2</superscript>+c, 
            (0&lt;=n) képlet alapján úgy, hogy a c az éppen vizsgált rácspont. 
            A z0 az origó. Alkalmazva a képletet a 
        </para>
        <itemizedlist>
            <listitem>
                <para>
                    z<subscript>0</subscript> = 0
                </para>
            </listitem>
            <listitem>
                <para>
                    z<subscript>1</subscript> = 0<superscript>2</superscript>+c = c
                </para>
            </listitem>
            <listitem>
                <para>
                    z<subscript>2</subscript> = c<superscript>2</superscript>+c
                </para>
            </listitem>
            <listitem>
                <para>
                    z<subscript>3</subscript> = (c<superscript>2</superscript>+c)<superscript>2</superscript>+c
                </para>
            </listitem>
            <listitem>
                <para>
                    z<subscript>4</subscript> = ((c<superscript>2</superscript>+c)<superscript>2</superscript>+c)<superscript>2</superscript>+c
                </para>
            </listitem>
            <listitem>
                <para>
                    ... s így tovább.
                </para>
            </listitem>
        </itemizedlist>
        <para>
            Azaz kiindulunk az origóból (z<subscript>0</subscript>) 
            és elugrunk a rács első pontjába a z<subscript>1</subscript> = c-be, 
            aztán a c-től függően a további z-kbe. Ha ez az utazás kivezet a 
            2 sugarú körből, akkor azt mondjuk, hogy az a vizsgált rácspont 
            nem a Mandelbrot halmaz eleme. Nyilván nem tudunk végtelen sok 
            z-t megvizsgálni, ezért csak véges sok z elemet nézünk meg minden 
            rácsponthoz. Ha eközben nem lép ki a körből, akkor feketére 
            színezzük, hogy az a c rácspont a halmaz része. (Színes meg úgy 
            lesz a kép, hogy változatosan színezzük, például minél későbbi 
            z-nél lép ki a körből, annál sötétebbre). 
        </para>       
        <programlisting language="c++">
            <![CDATA[
            #include <png++/png.hpp>
            #define N 500
            #define M 500
            #define MAXX 0.7
            #define MINX -2.0
            #define MAXY 1.35
            #define MINY -1.35
            void GeneratePNG( int tomb[N][M])
            {
                png::image< png::rgb_pixel > image(N, M);
                for (int x = 0; x < N; x++)
                {
                    for (int y = 0; y < M; y++)
                    {
                        image[x][y] = png::rgb_pixel(tomb[x][y], tomb[x][y], tomb[x][y]);
                    }
                }
                image.write("kimenet.png");
            }
            struct Komplex
            {
                double re, im;
            };
            int main()
            {
                int tomb[N][M];
                int i, j, k;
                double dx = (MAXX - MINX) / N;
                double dy = (MAXY - MINY) / M;
                struct Komplex C, Z, Zuj;
                int iteracio;
                for (i = 0; i < M; i++)
                {
                    for (j = 0; j < N; j++)
                    {
                        C.re = MINX + j * dx;
                        C.im = MAXY - i * dy;
                        Z.re = 0;
                        Z.im = 0;
                        iteracio = 0;
                        while(Z.re * Z.re + Z.im * Z.im < 4 && iteracio++ < 255)
                        {
                            Zuj.re = Z.re * Z.re - Z.im * Z.im + C.re;
                            Zuj.im = 2 * Z.re * Z.im + C.im;
                            Z.re = Zuj.re;
                            Z.im = Zuj.im;
                        }
                        tomb[i][j] = 256 - iteracio;
                    }
                }
                GeneratePNG(tomb);
                return 0;
            }
            ]]>
            </programlisting>
            <para>
                A Mandelbrot halmaz illeszkedik a 
                <inlineequation>
                <alt role="tex">f_c(z) = z^2 + c</alt>
                <mathphrase/>
                </inlineequation>
                függvény képére, és korlátos, mivel nullától iterálva nem divergál 
                <inlineequation>
                <alt role="tex">f_c(0), f_c(f_c(0)), ...</alt>
                <mathphrase/>
                </inlineequation>
                abszolútértékben.
            </para>
            <para>
                A program elején találtható egy GeneratePNG() függvény, mely a kiszámolt mátrix elemeiből a libpng 
                könyvtár segítségével felépít egy png képet. Ezt úgy teszi meg, hogy a main-ben már társítottunk a mátrix elemekhez 
                egy értéket, mely alapján eldönti, hogy az adott elemhez tartozó pixel milyen színű lesz (hiszen a képek is csak pixel 
                mátrixok). 
            </para>
            <para>
                Bár ez egy C++ program, hogy megjeleníthető legyen a halmaz kép formájában, de alapvetőleg C 
                alapú a kód, így a komplex számokat nem olyan triviális meghivatkozni (C++ban a complex utasítással ezt 
                könnyen megtehetjük, de erről a következő feladat fog szólni). Mivel egy komplex szám a legtöbb számmal ellentétben 
                két értékkel is rendelkezik (valós és imaginárius egység), ezért egy klasszikus számtípus nem elég. A megoldás egy 
                struktúra létrehozásában van. Ezért elkészítjük a Komplex struktúrát, mely két double értékkel fog rendelkezni. 
            </para>
            <para>
                Végül egy dupla for ciklus segítségével végig rohanunk a mátrix elemein és egyesével megvizsgájuk, 
                hogy mennyi próbálkozás után tud kilépni a halmazból (ha ki tud). Ezután 256-ból kivonjuk a próbálkozások számát. 
                Ez fogja adni a képünknek a színárnyalatát. Ha azonnal kilép, akkor nem része a halmaznak, és teljesen fehér lesz. 
                Minél tovább marad bent, annál sötétebb árnyalatott vesz fel. végül, ha 256 próbálkozás alatt, sem sikerül neki, az 
                azt jelenti, hogy része a Mandelbrot halmaznak, így teljesen fekete értéket kap.  
            </para>
            <para>
                A futtatáshoz szükséges makefile tartalma: 
            </para>
            <programlisting>
                <![CDATA[all: mandelbrot clean
                mandelbrot.o: mandelbrot.cpp
                    @g++ -c mandelbrot.cpp `libpng-config --cflags`
                mandelbrot: mandelbrot.o
                    @g++ -o mandelbrot mandelbrot.o `libpng-config --ldflags`
                clean:
                    @rm -rf *.o
                    @./mandelbrot
                    @rm -rf mandelbrot ]]>
            </programlisting>

    </section>        
        
    <section>
        <title>A Mandelbrot halmaz a <filename>std::complex</filename> osztállyal</title>
        <para>
            Írj olyan C++ programot, amely kiszámolja a Mandelbrot halmazt!                     
        </para>
        <para>
            Megoldás videó: <link xlink:href="https://youtu.be/gvaqijHlRUs">https://youtu.be/gvaqijHlRUs</link>
        </para>
        <para>
            Megoldás forrása:                
        </para>
        <para>        
A <link xlink:href="#bhax-textbook-feladatok-mandelbrot.Mandelbrot">Mandelbrot halmaz</link> pontban vázolt
ismert algoritmust valósítja meg a repó <link xlink:href="../../../bhax/attention_raising/Mandelbrot/3.1.2.cpp">
                <filename>bhax/attention_raising/Mandelbrot/3.1.2.cpp</filename>
            </link> nevű állománya.
        </para>
        
        <programlisting language="c++">
<![CDATA[// Verzio: 3.1.2.cpp
// Forditas:
// g++ 3.1.2.cpp -lpng -O3 -o 3.1.2
// Futtatas:
// ./3.1.2 mandel.png 1920 1080 2040 -0.01947381057309366392260585598705802112818 -0.0194738105725413418456426484226540196687 0.7985057569338268601555341774655971676111 0.798505756934379196110285192844457924366
// ./3.1.2 mandel.png 1920 1080 1020 0.4127655418209589255340574709407519549131 0.4127655418245818053080142817634623497725 0.2135387051768746491386963270997512154281 0.2135387051804975289126531379224616102874
// Nyomtatas:
// a2ps 3.1.2.cpp -o 3.1.2.cpp.pdf -1 --line-numbers=1  --left-footer="BATF41 HAXOR STR34M" --right-footer="https://bhaxor.blog.hu/" --pro=color
// ps2pdf 3.1.2.cpp.pdf 3.1.2.cpp.pdf.pdf
//
//
// Copyright (C) 2019
// Norbert Bátfai, batfai.norbert@inf.unideb.hu
//
//  This program is free software: you can redistribute it and/or modify
//  it under the terms of the GNU General Public License as published by
//  the Free Software Foundation, either version 3 of the License, or
//  (at your option) any later version.
//
//  This program is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FORA program elején találtható egy GeneratePNG() függvény, mely a kiszámolt mátrix elemeiből a libpng 
                könyvtár segítségével felépít egy png képet. Ezt úgy teszi meg, hogy a main-ben már társítottunk a mátrix elemekhez 
                egy értéket, mely alapján eldönti, hogy az adott elemhez tartozó pixel milyen színű lesz (hiszen a képek is csak pixel 
                mátrixok). y of the GNU General Public License
//  along with this program.  If not, see <https://www.gnu.org/licenses/>.


#include <iostream>
#include "png++/png.hpp"
#include <complex>

int
main ( int argc, char *argv[] )
{

  int szelesseg = 1920;
  int magassag = 1080;
  int iteraciosHatar = 255;
  double a = -1.9;
  double b = 0.7;
  double c = -1.3;
  double d = 1.3;

  if ( argc == 9 )
    {
      szelesseg = atoi ( argv[2] );
      magassag =  atoi ( argv[3] );
      iteraciosHatar =  atoi ( argv[4] );
      a = atof ( argv[5] );
      b = atof ( argv[6] );
      c = atof ( argv[7] );
      d = atof ( argv[8] );
    }
  else
    {
      std::cout << "Hasznalat: ./3.1.2 fajlnev szelesseg magassag n a b c d" << std::endl;
      return -1;
    }

  png::image < png::rgb_pixel > kep ( szelesseg, magassag );

  double dx = ( b - a ) / szelesseg;
  double dy = ( d - c ) / magassag;
  double reC, imC, reZ, imZ;
  int iteracio = 0;

  std::cout << "Szamitas\n";

  // j megy a sorokon
  for ( int j = 0; j < magassag; ++j )
    {
      // k megy az oszlopokon

      for ( int k = 0; k < szelesseg; ++k )
        {

          // c = (reC, imC) a halo racspontjainak
          // megfelelo komplex szam

          reC = a + k * dx;
          imC = d - j * dy;
          std::complex<double> c ( reC, imC );

          std::complex<double> z_n ( 0, 0 );
          iteracio = 0;

          while ( std::abs ( z_n ) < 4 && iteracio < iteraciosHatar )
            {
              z_n = z_n * z_n + c;

              ++iteracio;
            }

          kep.set_pixel ( k, j,
                          png::rgb_pixel ( iteracio%255, (iteracio*iteracio)%255, 0 ) );
        }

      int szazalek = ( double ) j / ( double ) magassag * 100.0;
      std::cout << "\r" << szazalek << "%" << std::flush;
    }

  kep.write ( argv[1] );
  std::cout << "\r" << argv[1] << " mentve." << std::endl;

}
]]>
        </programlisting>
        <para>
            Ennek a programnak a működése nagyon hasonló az előzőhöz, így pár részlet fölött elsiklanék.
            Viszont ami kiemelendő, hogy itt már ki is van használva a C++ egyes előnyei a C-vel szemben. Első 
            sorban, hogy itt már meghívásra került a Complex library, mely segítségével egyszerűbben hozhatunk létre 
            komplex számokat, anélkül, hogy ehhez struktúrát kéne használnuk. A másik, hogy az abs() függvény segítségével 
            a négyzetre emelést is egyszerűbb megtenni, meg a végeredmény is könnyebben érthető, mint hogy változók 
            vannak  megszorozva önmagukkal. 
        </para>
    </section>        
                
    <section>
        <title>Biomorfok</title>
        <para>
        </para>
        <para>
            Megoldás videó: <link xlink:href="https://youtu.be/IJMbgRzY76E">https://youtu.be/IJMbgRzY76E</link>
        </para>
        <para>
            Megoldás forrása: <link xlink:href="https://gitlab.com/nbatfai/bhax/tree/master/attention_raising/Biomorf">https://gitlab.com/nbatfai/bhax/tree/master/attention_raising/Biomorf</link>
        </para>
        <para>
            A biomorfokra (a Julia halmazokat rajzoló bug-os programjával) 
            rátaláló Clifford Pickover azt hitte természeti törvényre 
            bukkant: <link xlink:href="https://www.emis.de/journals/TJNSA/includes/files/articles/Vol9_Iss5_2305--2315_Biomorphs_via_modified_iterations.pdf">https://www.emis.de/journals/TJNSA/includes/files/articles/Vol9_Iss5_2305--2315_Biomorphs_via_modified_iterations.pdf</link> (lásd a 2307. oldal aljától).
        </para>       
        <para>
            A különbség a <link xlink:href="#bhax-textbook-feladatok-mandelbrot.Mandelbrot">Mandelbrot halmaz</link>
            és a Julia halmazok között az, hogy a komplex iterációban az előbbiben a c változó, utóbbiban pedig állandó. 
            A következő Mandelbrot csipet azt mutatja, hogy a c befutja a vizsgált összes rácspontot.
        </para> 
        <para>
            Ezeket kiegészíteném azzokkal az érdekességekkel, hogy Julia halmazból végtelen sok van, melyeket magába 
            foglal a Mandelbrot halmaz, melyből viszont csak egy létezik. Továbbá fontos lehet megjegyezni, hogy a biomorfok 
            speciális Pickover szálak, melyek hasonlítanak biológiai alakzatokra, példáúl sejtekre. Innen is ered a biomorf 
            elnevezés. 
        </para>      
        <programlisting language="c++">
<![CDATA[  // j megy a sorokon
  for ( int j = 0; j < magassag; ++j )
    {
      for ( int k = 0; k < szelesseg; ++k )
        {

          // c = (reC, imC) a halo racspontjainak
          // megfelelo komplex szam

          reC = a + k * dx;
          imC = d - j * dy;
          std::complex<double> c ( reC, imC );

          std::complex<double> z_n ( 0, 0 );
          iteracio = 0;

          while ( std::abs ( z_n ) < 4 && iteracio < iteraciosHatar )
            {
              z_n = z_n * z_n + c;

              ++iteracio;
            }
]]>
        </programlisting>        
        <para>
            Ezzel szemben a Julia halmazos csipetben a cc nem változik, hanem minden vizsgált
            z rácspontra ugyanaz.
        </para>
        <programlisting language="c++">
<![CDATA[    // j megy a sorokon
    for ( int j = 0; j < magassag; ++j )
    {
        // k megy az oszlopokon
        for ( int k = 0; k < szelesseg; ++k )
        {
            double reZ = a + k * dx;
            double imZ = d - j * dy;
            std::complex<double> z_n ( reZ, imZ );

            int iteracio = 0;
            for (int i=0; i < iteraciosHatar; ++i)
            {
                z_n = std::pow(z_n, 3) + cc;
                if(std::real ( z_n ) > R || std::imag ( z_n ) > R)
                {
                    iteracio = i;
                    break;
                }
            }
]]>
        </programlisting>                         
        
        <para>
            A bimorfos algoritmus pontos megismeréséhez ezt a cikket javasoljuk: 
            <link xlink:href="https://www.emis.de/journals/TJNSA/includes/files/articles/Vol9_Iss5_2305--2315_Biomorphs_via_modified_iterations.pdf">https://www.emis.de/journals/TJNSA/includes/files/articles/Vol9_Iss5_2305--2315_Biomorphs_via_modified_iterations.pdf</link>.
            Az is jó gyakorlat, ha magából ebből a cikkből from scratch kódoljuk be a sajátunkat, de mi a királyi úton járva a 
            korábbi <link xlink:href="#bhax-textbook-feladatok-mandelbrot.Mandelbrot">Mandelbrot halmazt</link> kiszámoló 
            forrásunkat módosítjuk. Viszont a program változóinak elnevezését összhangba hozzuk a közlemény jelöléseivel:
        </para>       
        <programlisting language="c++">
<![CDATA[// Verzio: 3.1.3.cpp
// Forditas:
// g++ 3.1.3.cpp -lpng -O3 -o 3.1.3
// Futtatas:
// ./3.1.3 bmorf.png 800 800 10 -2 2 -2 2 .285 0 10
// Nyomtatas:
// a2ps 3.1.3.cpp -o 3.1.3.cpp.pdf -1 --line-numbers=1  --left-footer="BATF41 HAXOR STR34M" --right-footer="https://bhaxor.blog.hu/" --pro=color
// 
// BHAX Biomorphs
// Copyright (C) 2019
// Norbert Batfai, batfai.norbert@inf.unideb.hu
//
//  This program is free software: you can redistribute it and/or modify
//  it under the terms of the GNU General Public License as published by
//  the Free Software Foundation, either version 3 of the License, or
//  (at your option) any later version.
//
//  This program is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//  GNU General Public License for more details.
//
//  You should have received a copy of the GNU General Public License
//  along with this program.  If not, see <https://www.gnu.org/licenses/>.
//
// Version history
//
// https://youtu.be/IJMbgRzY76E
// See also https://www.emis.de/journals/TJNSA/includes/files/articles/Vol9_Iss5_2305--2315_Biomorphs_via_modified_iterations.pdf
//

#include <iostream>
#include "png++/png.hpp"
#include <complex>

int
main ( int argc, char *argv[] )
{

    int szelesseg = 1920;
    int magassag = 1080;
    int iteraciosHatar = 255;
    double xmin = -1.9;
    double xmax = 0.7;
    double ymin = -1.3;
    double ymax = 1.3;
    double reC = .285, imC = 0;
    double R = 10.0;

    if ( argc == 12 )
    {
        szelesseg = atoi ( argv[2] );
        magassag =  atoi ( argv[3] );
        iteraciosHatar =  atoi ( argv[4] );
        xmin = atof ( argv[5] );
        xmax = atof ( argv[6] );
        ymin = atof ( argv[7] );
        ymax = atof ( argv[8] );
        reC = atof ( argv[9] );
        imC = atof ( argv[10] );
        R = atof ( argv[11] );

    }
    else
    {
        std::cout << "Hasznalat: ./3.1.2 fajlnev szelesseg magassag n a b c d reC imC R" << std::endl;
        return -1;
    }

    png::image < png::rgb_pixel > kep ( szelesseg, magassag );

    double dx = ( xmax - xmin ) / szelesseg;
    double dy = ( ymax - ymin ) / magassag;

    std::complex<double> cc ( reC, imC );

    std::cout << "Szamitas\n";

    // j megy a sorokon
    for ( int y = 0; y < magassag; ++y )
    {
        // k megy az oszlopokon

        for ( int x = 0; x < szelesseg; ++x )
        {

            double reZ = xmin + x * dx;
            double imZ = ymax - y * dy;
            std::complex<double> z_n ( reZ, imZ );

            int iteracio = 0;
            for (int i=0; i < iteraciosHatar; ++i)
            {

                z_n = std::pow(z_n, 3) + cc;
                //z_n = std::pow(z_n, 2) + std::sin(z_n) + cc;
                if(std::real ( z_n ) > R || std::imag ( z_n ) > R)
                {
                    iteracio = i;
                    break;
                }
            }

            kep.set_pixel ( x, y,
                            png::rgb_pixel ( (iteracio*20)%255, (iteracio*40)%255, (iteracio*60)%255 ));
        }

        int szazalek = ( double ) y / ( double ) magassag * 100.0;
        std::cout << "\r" << szazalek << "%" << std::flush;
    }

    kep.write ( argv[1] );
    std::cout << "\r" << argv[1] << " mentve." << std::endl;

}
]]>
        </programlisting>                           
        <para>
            Itt is azt figyeljük, hogy mikor hagyja el a halmazt, de itt már kicsit színesítünk a dolgokon. 
        </para>  
        <para>
            Futtatás az eredeti értékekkel: 
        </para>  
        <mediaobject>
            <imageobject>
                <imagedata fileref="./Pics/Biomorf3.png" format="PNG" scale="25"/>
            </imageobject>
        </mediaobject>
        <para>
            Futtatás módosított értékekkel (1): 
        </para>  
        <mediaobject>
            <imageobject>
                <imagedata fileref="./Pics/Biomorf2.png" format="PNG" scale="25"/>
            </imageobject>
        </mediaobject>    
        <para>
            Futtatás módosított értékekkel (2): 
        </para>  
        <mediaobject>
            <imageobject>
                <imagedata fileref="./Pics/Biomorf1.png" format="PNG" scale="25"/>
            </imageobject>
        </mediaobject>                     
                                                                            
    </section>                     

    <section>
        <title>A Mandelbrot halmaz CUDA megvalósítása</title>
        <para>
        </para>
        <para>
            Megoldás videó: <link xlink:href="https://youtu.be/gvaqijHlRUs">https://youtu.be/gvaqijHlRUs</link>
        </para>
        <para>
            Megoldás forrása:                
 <link xlink:href="../../../bhax/attention_raising/CUDA/mandelpngc_60x60_100.cu">
                <filename>bhax/attention_raising/CUDA/mandelpngc_60x60_100.cu</filename>
            </link> nevű állománya.            
        </para>
        <para>
            Ez a feladat azt hivatott szemléltetni, hogy milyen előnyei lehetnek az Nvidia által fejlesztett 
            cuda drivernek a grafikai megjelenítésben. A technológiát nagyon sokrétűen alkalmazzák, kezdve a 3D 
            grafikától (magam is használom a rendereltetéshez, mert jóval gyorsabban számól, mint a CPU) egészen a 
            játékokig. 
        </para>
        <para>
            Legnagyobb előnye a klasszikus OpenGL-el szemben, hogy nem a processzor használja a számításhoz, hanem a 
            videókártyát (fontos megjegyezni, hogy ez csak az nvidia viseókártyákra vonatkozik, az amd-sek itt hátrányban vannak)
            , azon belül is az úgynevezett cuda magokat. Típustól függően eltérő számú mag található a VGA-ban, de minden esetben 
            több százról van szó. 
        </para>
        <para>
            Az alábbi példában kiosztjuk a generálni kívánt kép (vagy hívhatjuk renderelésnek is) pixeleit egy-egy 
            cuda magnak és meglátjuk mi lesz. 
        </para>
        <para>
            Eddig ha le akartunk renderelni egy Mandelbrot halmazt, az hosszú másodpercekig is eltarthat (nyílván ez nem olyan 
            vészes, de egy komolyabb számítás esettén a szükséges idő is arányosan hatványozódik), míg a cuda render esetén ez a 
            másodperc tört része csupán. De hogy történt ez? 
        </para>
        <para>
            Ahogy a római mondás is tartja: Divide et Impera (oszd meg és uralkodj).
            Ahelyett, hogy ezt a bonyolult feladatot pár darab processzor magra sózzuk (jelen esetben 4 magról van szó),
            inkább kiszervezzük párszáz cuda magnak. Szerintem nem kell sokat magyaráznom, hogy mi a különbség. Közösen 
            pillanatok alatt végeznek a számítással és még csak kicsit se terhelik le a rendszer. 
            De ne csak a levegőbe beszéljünk, jöjjenek a számok: 
        </para>
        <screen>
            <![CDATA[ 
            $ make
            35
            0.360183 sec
            ]]>
        </screen>
    </section>                     

    <section>
        <title>Mandelbrot nagyító és utazó C++ nyelven</title>
        <para>
            Építs GUI-t a Mandelbrot algoritmusra, lehessen egérrel nagyítani egy területet, illetve egy pontot
            egérrel kiválasztva vizualizálja onnan a komplex iteréció bejárta z<subscript>n</subscript> komplex számokat!
        </para>
        <para>
            Megoldás videó: <link xlink:href=""></link>
            Illetve <link xlink:href="https://bhaxor.blog.hu/2018/09/02/ismerkedes_a_mandelbrot_halmazzal">https://bhaxor.blog.hu/2018/09/02/ismerkedes_a_mandelbrot_halmazzal</link>.        </para>
        <para>
            Megoldás forrása: <link xlink:href=""></link>
        </para>
        <para>
            Ebben a feladatban az volt a lényeg, hogy a korábban használt Mandelbrot programunknak grafikus felhasználói 
            felületetet (Graphic User Interface - GUI) hozzunk létre. Ehhez segítségűl hívjuk a QT program könyvtárait és objektum 
            orientáltá alakítjuk a programunkat. 
        </para>
        <para>
            Létrehoztunk egy frakablak nevű programot, mely segítségével a terminál helyet már rendesen ablakban futtathtó a programunk, 
            melyben megjeleníthető a mandelbrot. 
        </para>
        <mediaobject>
            <imageobject>
                <imagedata fileref="./Pics/nagyito.png" format="PNG" scale="50"/>
            </imageobject>
        </mediaobject>
        <mediaobject>
            <imageobject>
                <imagedata fileref="./Pics/nagyito1.png" format="PNG" scale="50"/>
            </imageobject>
        </mediaobject>      
        <mediaobject>
            <imageobject>
                <imagedata fileref="./Pics/nagyito2.png" format="PNG" scale="50"/>
            </imageobject>
        </mediaobject>            
    </section>                     
                                                                                                                                                                            
    <section>
        <title>Mandelbrot nagyító és utazó Java nyelven</title>
        <para>
        </para>
        <para>
            Megoldás videó: <link xlink:href="https://youtu.be/Ui3B6IJnssY">https://youtu.be/Ui3B6IJnssY</link>, 4:27-től.
            Illetve <link xlink:href="https://bhaxor.blog.hu/2018/09/02/ismerkedes_a_mandelbrot_halmazzal">https://bhaxor.blog.hu/2018/09/02/ismerkedes_a_mandelbrot_halmazzal</link>.
        </para>
        <para>
            Megoldás forrása: <link xlink:href="https://www.tankonyvtar.hu/hu/tartalom/tkt/javat-tanitok-javat/apbs02.html#id570518">https://www.tankonyvtar.hu/hu/tartalom/tkt/javat-tanitok-javat/apbs02.html#id570518</link>
        </para>
        <para>
            Az előző feladat java átírata. Ennek fordításához és futtatásához szükséges rendelkezni 
            az openjdk8-as csomaggal. 
        </para>
        <para>
            A telepítés: 
        </para>
        <screen>
            <![CDATA[
            sudo apt-get install openjdk-8-jdk  
            ]]>
        </screen>
        <para>A következő program Bátfai Norbert munkája:  </para>
        <programlisting language = "java">
            <![CDATA[ 
                            
/*
* MandelbrotHalmaz.java
*
* DIGIT 2005, Javat tanítok
* Bátfai Norbert, nbatfai@inf.unideb.hu
*
*/
/**
* A Mandelbrot halmazt kiszámoló és kirajzoló osztály.
*
* @author Bátfai Norbert, nbatfai@inf.unideb.hu
* @version 0.0.1
*/
public class MandelbrotHalmaz extends java.awt.Frame implements Runnable {
   /** A komplex sík vizsgált tartománya [a,b]x[c,d]. */
   protected double a, b, c, d;
   /** A komplex sík vizsgált tartományára feszített
    * háló szélessége és magassága. */
   protected int szélesség, magasság;
   /** A komplex sík vizsgált tartományára feszített hálónak megfelelő kép.*/
   protected java.awt.image.BufferedImage kép;
   /** Max. hány lépésig vizsgáljuk a z_{n+1} = z_n * z_n + c iterációt?
    * (tk. most a nagyítási pontosság) */
   protected int iterációsHatár = 255;
   /** Jelzi, hogy éppen megy-e a szamítás? */
   protected boolean számításFut = false;
   /** Jelzi az ablakban, hogy éppen melyik sort számoljuk. */
   protected int sor = 0;
   /** A pillanatfelvételek számozásához. */
   protected static int pillanatfelvételSzámláló = 0;
   /**
    * Létrehoz egy a Mandelbrot halmazt a komplex sík
    * [a,b]x[c,d] tartománya felett kiszámoló
    * <code>MandelbrotHalmaz</code> objektumot.
    *
    * @param      a              a [a,b]x[c,d] tartomány a koordinátája.
    * @param      b              a [a,b]x[c,d] tartomány b koordinátája.
    * @param      c              a [a,b]x[c,d] tartomány c koordinátája.
    * @param      d              a [a,b]x[c,d] tartomány d koordinátája.
    * @param      szélesség      a halmazt tartalmazó tömb szélessége.
    * @param      iterációsHatár a számítás pontossága.
    */
   public MandelbrotHalmaz(double a, double b, double c, double d,
           int szélesség, int iterációsHatár) {
       this.a = a;
       this.b = b;
       this.c = c;
       this.d = d;
       this.szélesség = szélesség;
       this.iterációsHatár = iterációsHatár;
       // a magasság az (b-a) / (d-c) = szélesség / magasság
       // arányból kiszámolva az alábbi lesz:
       this.magasság = (int)(szélesség * ((d-c)/(b-a)));
       // a kép, amire rárajzoljuk majd a halmazt
       kép = new java.awt.image.BufferedImage(szélesség, magasság,
               java.awt.image.BufferedImage.TYPE_INT_RGB);
       // Az ablak bezárásakor kilépünk a programból.
       addWindowListener(new java.awt.event.WindowAdapter() {
           public void windowClosing(java.awt.event.WindowEvent e) {
               setVisible(false);
               System.exit(0);
           }
       });
       // A billentyűzetről érkező események feldolgozása
       addKeyListener(new java.awt.event.KeyAdapter() {
           // Az 's', 'n' és 'm' gombok lenyomását figyeljük 
           public void keyPressed(java.awt.event.KeyEvent e) {
               if(e.getKeyCode() == java.awt.event.KeyEvent.VK_S)
                   pillanatfelvétel();
               // Az 'n' gomb benyomásával pontosabb számítást végzünk.
               else if(e.getKeyCode() == java.awt.event.KeyEvent.VK_N) {
                   if(számításFut == false) {
                       MandelbrotHalmaz.this.iterációsHatár += 256;
                       // A számítás újra indul:
                       számításFut = true;
                       new Thread(MandelbrotHalmaz.this).start();
                   }
               // Az 'm' gomb benyomásával pontosabb számítást végzünk,
               // de közben sokkal magasabbra vesszük az iterációs
               // határt, mint az 'n' használata esetén
               } else if(e.getKeyCode() == java.awt.event.KeyEvent.VK_M) {
                   if(számításFut == false) {
                       MandelbrotHalmaz.this.iterációsHatár += 10*256;
                       // A számítás újra indul:
                       számításFut = true;
                       new Thread(MandelbrotHalmaz.this).start();
                   }
               }
           }
       });
       // Ablak tulajdonságai
       setTitle("A Mandelbrot halmaz");
       setResizable(false);
       setSize(szélesség, magasság);
       setVisible(true);
       // A számítás indul:
       számításFut = true;
       new Thread(this).start();
   }
   /**
    * A halmaz aktuális állapotának kirajzolása.
    */
   public void paint(java.awt.Graphics g) {
       // A Mandelbrot halmaz kirajzolása
       g.drawImage(kép, 0, 0, this);
       // Ha éppen fut a számítás, akkor egy vörös
       // vonallal jelöljük, hogy melyik sorban tart:
       if(számításFut) {
           g.setColor(java.awt.Color.RED);
           g.drawLine(0, sor, getWidth(), sor);
       }
   }
   // Ne villogjon a felület (mert a "gyári" update()
   // lemeszelné a vászon felületét).
   public void update(java.awt.Graphics g) {
       paint(g);
   }
   /**
    * Pillanatfelvételek készítése.
    */
   public void pillanatfelvétel() {
       // Az elmentendő kép elkészítése:
       java.awt.image.BufferedImage mentKép =
               new java.awt.image.BufferedImage(szélesség, magasság,
               java.awt.image.BufferedImage.TYPE_INT_RGB);
       java.awt.Graphics g = mentKép.getGraphics();
       g.drawImage(kép, 0, 0, this);
       g.setColor(java.awt.Color.BLUE);
       g.drawString("a=" + a, 10, 15);
       g.drawString("b=" + b, 10, 30);
       g.drawString("c=" + c, 10, 45);
       g.drawString("d=" + d, 10, 60);
       g.drawString("n=" + iterációsHatár, 10, 75);
       g.dispose();
       // A pillanatfelvétel képfájl nevének képzése:
       StringBuffer sb = new StringBuffer();
       sb = sb.delete(0, sb.length());
       sb.append("MandelbrotHalmaz_");
       sb.append(++pillanatfelvételSzámláló);
       sb.append("_");
       // A fájl nevébe belevesszük, hogy melyik tartományban
       // találtuk a halmazt:
       sb.append(a);
       sb.append("_");
       sb.append(b);
       sb.append("_");
       sb.append(c);
       sb.append("_");
       sb.append(d);
       sb.append(".png");
       // png formátumú képet mentünk
       try {
           javax.imageio.ImageIO.write(mentKép, "png",
                   new java.io.File(sb.toString()));
       } catch(java.io.IOException e) {
           e.printStackTrace();
       }
   }
   /** 
    * A Mandelbrot halmaz számítási algoritmusa.
    * Az algoritmus részletes ismertetését lásd például a
    * [BARNSLEY KÖNYV] (M. Barnsley: Fractals everywhere, 
    * Academic Press, Boston, 1986) hivatkozásban vagy 
    * ismeretterjesztő szinten a [CSÁSZÁR KÖNYV] hivatkozásban.
    */     
    public void run() {
       // A [a,b]x[c,d] tartományon milyen sűrű a
       // megadott szélesség, magasság háló:
       double dx = (b-a)/szélesség;
       double dy = (d-c)/magasság;
       double reC, imC, reZ, imZ, ujreZ, ujimZ;
       int rgb;
       // Hány iterációt csináltunk?
       int iteráció = 0;
       // Végigzongorázzuk a szélesség x magasság hálót:
       for(int j=0; j<magasság; ++j) {
           sor = j;
           for(int k=0; k<szélesség; ++k) {
               // c = (reC, imC) a háló rácspontjainak
               // megfelelő komplex szám
               reC = a+k*dx;
               imC = d-j*dy;
               // z_0 = 0 = (reZ, imZ)
               reZ = 0;
               imZ = 0;
               iteráció = 0;
               // z_{n+1} = z_n * z_n + c iterációk
               // számítása, amíg |z_n| < 2 vagy még
               // nem értük el a 255 iterációt, ha
               // viszont elértük, akkor úgy vesszük,
               // hogy a kiinduláci c komplex számra
               // az iteráció konvergens, azaz a c a
               // Mandelbrot halmaz eleme
               while(reZ*reZ + imZ*imZ < 4 && iteráció < iterációsHatár) {
                   // z_{n+1} = z_n * z_n + c
                   ujreZ = reZ*reZ - imZ*imZ + reC;
                   ujimZ = 2*reZ*imZ + imC;
                   reZ = ujreZ;
                   imZ = ujimZ;
                   
                   ++iteráció;
                   
               }
               // ha a < 4 feltétel nem teljesült és a
               // iteráció < iterációsHatár sérülésével lépett ki, azaz
               // feltesszük a c-ről, hogy itt a z_{n+1} = z_n * z_n + c
               // sorozat konvergens, azaz iteráció = iterációsHatár
               // ekkor az iteráció %= 256 egyenlő 255, mert az esetleges
               // nagyítasok során az iteráció = valahány * 256 + 255
               iteráció %= 256;
               // így a halmaz elemeire 255-255 értéket használjuk,
               // azaz (Red=0,Green=0,Blue=0) fekete színnel:
               rgb = (255-iteráció)|
                       ((255-iteráció) << 8) |
                       ((255-iteráció) << 16);
               // rajzoljuk a képre az éppen vizsgált pontot:
               kép.setRGB(k, j, rgb);
           }
           repaint();
       }
       számításFut = false;
   }
   /**
    * Példányosít egy Mandelbrot halmazt kiszámoló obektumot.
    */
   public static void main(String[] args) {
       // A halmazt a komplex sík [-2.0, .7]x[-1.35, 1.35] tartományában
       // keressük egy 400x400-as hálóval:
       new MandelbrotHalmaz(-2.0, .7, -1.35, 1.35, 600, 255);
   }
}                               
            ]]>
        </programlisting>
        <para>
            Daraboljuk fel és nézzük meg a függvényeket részenként. Itt már a kommenteket és a licenset kihagyom helytakarékosság célján: 
        </para>
        <programlisting language = "java">
            <![CDATA[ 
public class MandelbrotHalmaz extends java.awt.Frame implements Runnable {
    protected double a, b, c, d;
    protected int szélesség, magasság;
    protected java.awt.image.BufferedImage kép;
    protected int iterációsHatár = 255;
    protected boolean számításFut = false;
    protected int sor = 0;
    protected static int pillanatfelvételSzámláló = 0;
}
    ]]>
        </programlisting>
        <para>
            Itt még nagy csoda nem történik. Az osztályon belül létrehozzuk a szükséges változókat. 
        </para>
        <programlisting language = "java">
            <![CDATA[ 
public MandelbrotHalmaz(double a, double b, double c, double d,
        int szélesség, int iterációsHatár) {
    this.a = a;
    this.b = b;
    this.c = c;
    this.d = d;
    this.szélesség = szélesség;
    this.iterációsHatár = iterációsHatár;
    this.magasság = (int)(szélesség * ((d-c)/(b-a)));
    kép = new java.awt.image.BufferedImage(szélesség, magasság,
            java.awt.image.BufferedImage.TYPE_INT_RGB);

    addWindowListener(new java.awt.event.WindowAdapter() {
        public void windowClosing(java.awt.event.WindowEvent e) {
            setVisible(false);
            System.exit(0);
        }
    });

    addKeyListener(new java.awt.event.KeyAdapter() {
        public void keyPressed(java.awt.event.KeyEvent e) {
            if(e.getKeyCode() == java.awt.event.KeyEvent.VK_S)
                pillanatfelvétel();

            else if(e.getKeyCode() == java.awt.event.KeyEvent.VK_N) {
                if(számításFut == false) {
                    MandelbrotHalmaz.this.iterációsHatár += 256;
                    számításFut = true;
                    new Thread(MandelbrotHalmaz.this).start();
                }

            } else if(e.getKeyCode() == java.awt.event.KeyEvent.VK_M) {
                if(számításFut == false) {
                    MandelbrotHalmaz.this.iterációsHatár += 10*256;
                    számításFut = true;
                    new Thread(MandelbrotHalmaz.this).start();
                }
            }
        }
    });
    setTitle("A Mandelbrot halmaz");
    setResizable(false);
    setSize(szélesség, magasság);
    setVisible(true);
    számításFut = true;
    new Thread(this).start();
}
    ]]>
        </programlisting>
        <para>
            Az első függvényünk egyből maga fő függvény. A változóknak átadjuk a paraméterként kapott értékeket, a <varname>magassag</varname> esetén kiszámoljuk azt. Az <function>addWindowListener</function>-ben 
            létrehozzuk a <function>windowClosing</function> függvényt ami egyszerűen csak az ablak bezárásáért felel. Ezután jön egy kicsit érdekesebb rész a <function>addKeyListener</function>-ben, ahol 
            konkrétan billenytűket fogunk figyelni hogy különböző utasításokat hajtsunk végre. Ha megnyomjuk az "s"-t azzal meghívjuk a <function>pillanatfelvétel</function>-t ami screenshotot készít majd a halmazról. 
            Amikor az "n" gombot ütjük le, akkor az iterációs határt megnöveljük 256-al és újraszámoltatjuk a halmazt egy pontosabb eredményért. Hasonlóan jár el az "m" billenytű is, azzal a különbséggel, 
            hogy itt nem 256-al növelünk, hanem a 2560-al, azaz a tízszeresével. Végül pedig beállítjuk az ablak tulajdonságait, úgyis mint a címét, megtiltjuk az átméretezést, meghatározzuk a méretet és láthatóvá 
            tesszük (ez utóbbi tulajdonságát megvonjuk a bezárás előtt). 
        </para>
        <programlisting language = "java">
            <![CDATA[ 
public void paint(java.awt.Graphics g) {
    g.drawImage(kép, 0, 0, this);
    if(számításFut) {
        g.setColor(java.awt.Color.RED);
        g.drawLine(0, sor, getWidth(), sor);
    }
}

public void update(java.awt.Graphics g) {
    paint(g);
}

public void pillanatfelvétel() {
    java.awt.image.BufferedImage mentKép =
            new java.awt.image.BufferedImage(szélesség, magasság,
            java.awt.image.BufferedImage.TYPE_INT_RGB);
    java.awt.Graphics g = mentKép.getGraphics();
    g.drawImage(kép, 0, 0, this);
    g.setColor(java.awt.Color.BLUE);
    g.drawString("a=" + a, 10, 15);
    g.drawString("b=" + b, 10, 30);
    g.drawString("c=" + c, 10, 45);
    g.drawString("d=" + d, 10, 60);
    g.drawString("n=" + iterációsHatár, 10, 75);
    g.dispose();

    StringBuffer sb = new StringBuffer();
    sb = sb.delete(0, sb.length());
    sb.append("MandelbrotHalmaz_");
    sb.append(++pillanatfelvételSzámláló);
    sb.append("_");

    sb.append(a);
    sb.append("_");
    sb.append(b);
    sb.append("_");
    sb.append(c);
    sb.append("_");
    sb.append(d);
    sb.append(".png");

    try {
        javax.imageio.ImageIO.write(mentKép, "png",
                new java.io.File(sb.toString()));
    } catch(java.io.IOException e) {
        e.printStackTrace();
    }
}
    ]]>
        </programlisting>
        <para>
            A következő szakasz három függvényt tartalmaz. Az első a <function>paint</function> Ő felel azért hogy a mandelbrot halmaz meg is jelenjen a képernyőkön. Másik extra feature, hogy 
            ha újra számoltatjuk a halmazt esetlegesen egy nagyobb iterációban, akkor kirajzoltatunk vele egy piros vonalat, ami abban a sorban fog elhelyezkedni, ahol a számítás is tart. Semmi ördöngősség, 
            csak egy kis apróság, mely sokat dob a program megjelenésén és segít vizualizálni, hogy hol tart az újraszámítás. 
            Ezt követi az <function>update</function>, mely egyszerűen csak folyamatosan meghívja a <function>paint</function>-et, azaz frissíti a halmazunk állapotát, ahogy a neve is sugalja. 
            Végül pedig a <function>pillanatkep</function>. Az előző bekezdésben említettem, hogy ezzel szeretnénk screenshot-okat kimenteni png formátumba. Ez elsőre bonyultan hangozhat, de nem olyan vészes. 
            Létrehozunk egy új pufferelt képet, kirajzoltatjuk a képet, majd rá kékkel az iteráció szempontjából fontosabb változókat. Ha a kép megvan, akkor már csak el kéne nevezni valahogy. Ehhez kell 
            egy új <type>StringBuffer</type> amiben ezt tároljuk. Ez tartalmazza a nevét, a kép sorszámát, a fontosabb változókat (a, b, c és d), majd végül ugye a kiterjesztést. Ezt mind szépen összefűzzük. 
            És már adjuk is át a javax.imageio.ImageIO.write(mentKép, "png", new java.io.File(sb.toString()));-nak hogy elkészítse magát a képet. 
        </para>
        <programlisting language = "java">
            <![CDATA[ 
public void run() {
    double dx = (b-a)/szélesség;
    double dy = (d-c)/magasság;
    double reC, imC, reZ, imZ, ujreZ, ujimZ;
    int rgb;
    int iteráció = 0;
    for(int j=0; j<magasság; ++j) {
        sor = j;
        for(int k=0; k<szélesség; ++k) {
            reC = a+k*dx;
            imC = d-j*dy;
            reZ = 0;
            imZ = 0;
            iteráció = 0;
            while(reZ*reZ + imZ*imZ < 4 && iteráció < iterációsHatár) {

                ujreZ = reZ*reZ - imZ*imZ + reC;
                ujimZ = 2*reZ*imZ + imC;
                reZ = ujreZ;
                imZ = ujimZ;
                
                ++iteráció;
                
            }
            iteráció %= 256;
            rgb = (255-iteráció)|
                    ((255-iteráció) << 8) |
                    ((255-iteráció) << 16);
            kép.setRGB(k, j, rgb);
        }
        repaint();
    }
    számításFut = false;
}

public static void main(String[] args) {
    new MandelbrotHalmaz(-2.0, .7, -1.35, 1.35, 600, 255);
}
    ]]>
        </programlisting>
        <para>
            Végül pedig itt a lényeg, a <function>run</function>, ahol a varázslat végbemegy. Felvesszük a szükséges változókat, köztük a komplex számoknak is. Aztán jön egy klasszikus 
             sorfolytonos mátrix bejárás, hogy képünk minden pixelét meghatározzuk. Itt már a felvett változókból elkészítjük a valódi komplex számainkat és utánna megvizsgáljuk, hogy hány iteráció 
             alatt sikerül elhagynia a halmazt, ha sikerül persze. Az elv ugyan az mint a korábbi verzióknál, ezt nem részletezném különösebben.   Majd azalapján hogy ez mennyi időbe telt neki, 
             kap egy szín értéket. Soronként újrahívjuk a <function>repaint</function> függvényt, hogy nyomonkövethető legyen a folyamat, majd ha az utolsóval is végzett, akkor egyszerűen hamisra 
             állítjuk a <varname>számításFut</varname>-ot ezzel jelezvén más függvényeknek, hogy végeztünk. Végül pedig a <function>void</function> ami egyszerűen csak megfelelően felparaméterezve meghívja 
             a <function>MandelbrotHalmaz</function>-t.  
        </para>
        <para>
            Fordítás és futtatás: 
        </para>
        <screen>
            <![CDATA[
            javac MandelbrotHalmaz.java
            java MandelbrotHalmaz
            ]]>
        </screen>
        <mediaobject>
            <imageobject>
                <imagedata fileref="./Pics/mandelJava.png" format="PNG" scale="50"/>
            </imageobject>
        </mediaobject>
        <mediaobject>
            <imageobject>
                <imagedata fileref="./Pics/mandelJava1.png" format="PNG" scale="50"/>
            </imageobject>
        </mediaobject>
        <mediaobject>
            <imageobject>
                <imagedata fileref="./Pics/mandelJava2.png" format="PNG" scale="50"/>
            </imageobject>
        </mediaobject>
    </section>
    <section>
        <title>Malmo: láváig fel, majd vissza le</title>
        <para>
            <link xlink:href="https://youtu.be/zO6cNp8L4-Q">https://youtu.be/zO6cNp8L4-Q</link>
        </para>
    </section>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        
</chapter>                
