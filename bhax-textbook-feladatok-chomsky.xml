<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <info>
        <title>Helló, Chomsky!</title>
        <keywordset>
            <keyword/>
        </keywordset>
    </info>
    <section>
        <title>Decimálisból unárisba átváltó Turing gép</title>
        <para>
            Állapotátmenet gráfjával megadva írd meg ezt a gépet!
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása:
        </para>
        <para>
            Az unáris számrendszer az egyes számrendszer. Ez azt jelenti, hogy kizárólag az '1'-es számmal dolgozik, így leegyszerűsítve
            a decimálisból (10-es számrendszer) unárisba való átváltás annyit tesz, hogy annyiszor írjuk le az egyest, amennyi a decimális 
            szám értéke (pl.: a 3: 111 vagy a 8: 111 11111). Gyakran szokták az egyeseket ötösével csoportosítani, a könnyebb 
            olvasás érdekében. 
            Pl.: A klasszikus ábrázolás, mikor a rabok a börtön falán vonalakkal jegyzik fel az eltelt napok számát.
        </para>
        <mediaobject>
            <imageobject>
                <imagedata fileref="Pics/TuringDecToUnary.png" scale="37" />
            </imageobject>
            <textobject>
                <phrase>Decimálisból unárisba váltó Turing gép állapotgráfja</phrase>
            </textobject>
        </mediaobject>
        <para>
            Az ábrán a Turing gép ezt úgy oldja meg, hogy az adott számból nulla nem lesz. Közben minden kivonás után eltárolja a 
            levont egyeseket. A műveletet az utolsó számjegytől kezdi. Ha ez az érték nulla, akkor kilenccel folytatja a 'kék' 
            állapottal, majd addig folytatja a kivonást míg az megint nulla lesz. Ha nem nullával kezdődik, akkor addig léptetjük,
            míg nulla értéket nem találunk. A kivonások számát eközben eltároljuk.
        </para>
        <para>
            Ma már kicsit egyszerűbb a helyzet amit az alábbi példa is szemléltet: 
        </para>
            <programlisting language="c">
                <![CDATA[ #include <stdio.h>

                    void converter(int dec)
                    {
                        if (dec != 0)
                        {
                            converter(dec - 1);
                            printf("1");
                        }
                    }
                    
                    int main() 
                    {
                        int dec;
                    
                        printf("Ird be a valtani kivant decimalis szamot: \n");
                        scanf("%d", &dec);
                    
                        converter(dec);
                    
                        return 0;
                    }
                    ]]>
            </programlisting>
    </section>        
<!--
    <section>
        <title>Passzolva: Az a<superscript>n</superscript>b<superscript>n</superscript>c<superscript>n</superscript> nyelv nem környezetfüggetlen</title>
        <para>
            Mutass be legalább két környezetfüggő generatív grammatikát, amely ezt a nyelvet generálja!
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása:                
        </para>
        <para>
            Tanulságok, tapasztalatok, magyarázat...
        </para>
    </section>        
-->
    <section>
        <title>Hivatkozási nyelv</title>
        <para>
            A <citation>KERNIGHANRITCHIE</citation> könyv C referencia-kézikönyv/Utasítások melléklete alapján definiáld 
            BNF-ben a C utasítás fogalmát!
            Majd mutass be olyan kódcsipeteket, amelyek adott szabvánnyal nem fordulnak (például C89), mással (például C99) igen.
        </para>
        <para>
            Megoldás videó: 
        </para>
        <para>
            Megoldás forrása:  
        </para>
        <para>
            Mi is az a BNF? 
            A BNF környezet független szintaxisokat leíró szintaxis, tehát lényegében egy nyelvtan a nyelvtanokhoz. 
        </para>
        <para>
            A C utasítás BNF megfogalmazása:
        </para>
            <programlisting language="algol">
                <![CDATA[
                   
<utasítás>::=
         <összetett_utasítás>
         <kifejezés>; (értékadás pl, num=10)
         if(<kifejezés>) <utasítás>
         else if(<kifejezés>) <utasítás>
         else <utasítás>
         switch (<kifejezés)
         <egész_konstans_kifejezés> : <utasítás>
         goto <azonosító>;
         <azonosító> : <utasítás>
         break; continue; return<kifejezés>;
         or(<kifejezés1><kifejezés2><kifejezés3>) <utasítás>
         while(<kifejezés>) <utasítás>
         do <utasítás> while<kifejezés>
         ; (üres utasítás, pl FORTRAN continue-ja)

]]>
        </programlisting>
        <para>
            Példa c89-el nem forduló, de c99-el forduló programra: 
        </para>
        <para>
            <programlisting language="c">
                <![CDATA[
int main()
{
    for (int i = 0; i < 10; i++)
    {
        //do something
    }

    return 0;
}
                ]]>
    </programlisting>
        </para>
        <para>
            Ennél a példánál 2 hibát is fogunk kapni, ha c89-el próbáljuk fordítani. 
            Az első, hogy nem deklarálhatunk változót a ciklusban (c99-től támogatott).
            A másik, hogy nem használható a '//' jelölés kommenthez, mert az csak c90-től támogatott. 
        </para>
    </section>                     

    <section>
        <title>Saját lexikális elemző</title>
        <para>
            Írj olyan programot, ami számolja a bemenetén megjelenő valós számokat! 
            Nem elfogadható olyan megoldás, amely maga olvassa betűnként a bemenetet, 
            a feladat lényege, hogy lexert használjunk, azaz óriások vállán álljunk és ne kispályázzunk!
        </para>
        <para>
            Megoldás videó: <link xlink:href="https://youtu.be/9KnMqrkj_kU">https://youtu.be/9KnMqrkj_kU</link> (15:01-től).
        </para>
        <para>
            Megoldás forrása: <link xlink:href="Chomsky/realnumber.l">
                <filename>bhax/thematic_tutorials/bhax_textbook_IgyNeveldaProgramozod/Chomsky/realnumber.l</filename>
            </link> 
        </para>
        <para>
            A lexer programok segítségével tudunk generálni szövegolvasó/elemző programokat. Lényegében arról van szó, hogy 
            olyan programokat írhatunk amik képesek más szövegeket (akár programok forráskódját is) "értelmezni" és előre megadott 
            típusú adatokat kinyerni belőle vagy megváltoztatni azt. 
        </para>
        <programlisting language="c"><![CDATA[
            %{
            #include <stdio.h>
            int realnumbers = 0;
            %}
            digit	[0-9]
            %%
            {digit}*(\.{digit}+)?	{++realnumbers; 
                printf("[realnum=%s %f]", yytext, atof(yytext));}
            %%
            int
            main ()
            {
            yylex ();
            printf("The number of real numbers is %d\n", realnumbers);
            return 0;
            }
            ]]>
        </programlisting>
        <para>
            A forráskód 3 fő részre bontható: 
        </para>
        <orderedlist>
            <listitem>
                <para>
                    Definíciók helye. Ide olyan dolgok kerülnek (pl változók), melyek biztosan benne lesznek a forrásszövegben.
                </para>
            </listitem>
            <listitem>
                <para>
                    Szabályok helye. A példában valós számokat keresünk, tehát a szabályunk olyan számokat keress, hogy tetszőleges számjegy 
                    mely után lehet (de nem kötelezően) '.' karakterrel elválasztva további tetszőleges számú számjegy. 
                </para>
            </listitem>
            <listitem>
                <para>
                    Az utolsó részben helyezkedik el a main függvény, ahova a saját utasításainkat írjuk. 
                </para>
            </listitem>
        </orderedlist>
        <para>
            Ebben a példában valós számokat kell keresnünk. A valós számok legalább egy számból állnak ugye (<varname>{digit}*</varname>)
            és ezen felül még egy lebegő pont után tetszőleges mennyiségű szám karakter szerepelhet (<varname>(\.{digit}+)?</varname>).
            Ha ilyet találunk akkor növeljük a <varname>realnumbers</varname>-t egyel és kiíratjuk a talált számot. Végül ha a program végzet 
            a szöveg olvasásával, akkor kiírattatjuk vele a talált valós számok számát. 
        </para>
        <para>
            Egyszerű kis program, de jól érzékelteti, hogy milyen potenciál lehet egy olyan verzióban ahol kicsit specifikusabban keresünk. 
            Írhatunk esetleg szabályt arra, hogy a program forráskódban keressen általános szintaktikai hibát (lemaradt ";" például). Ha meg 
            esetleg kiegészítjük egy intelligens ágenssel akkor pedig végkép. Jelenleg is folynak kutatások olyan MI írására mely exploitálhat 
            bugokat (kihasználható hibákat) keres több ezer vagy tízezer soros forrásokban, hogy elkerüljék a potenciális támadási felületeket. 
            Szerintem nem kell hangsúlyoznom hogy ennek mindkét oldalon milyen erős szerepe lenne. 
        </para>

    </section>                     

    <section>
        <title>Leetspeak</title>
        <para>
            Lexelj össze egy l33t ciphert!
        </para>
        <para>
            Megoldás videó: <link xlink:href="https://youtu.be/06C_PqDpD_k">https://youtu.be/06C_PqDpD_k</link>
        </para>
        <para>
            Megoldás forrása: <link xlink:href="Chomsky/l337d1c7.l">
                <filename>bhax/thematic_tutorials/bhax_textbook_IgyNeveldaProgramozod/Chomsky/l337d1c7.l</filename>
            </link>  
        </para>
        <programlisting language="c"><![CDATA[%{
  #include <stdio.h>
  #include <stdlib.h>
  #include <time.h>
  #include <ctype.h>

  #define L337SIZE (sizeof l337d1c7 / sizeof (struct cipher))
    
  struct cipher {
    char c;
    char *leet[4];
  } l337d1c7 [] = {

  {'a', {"4", "4", "@", "/-\\"}},
  {'b', {"b", "8", "|3", "|}"}},
  {'c', {"c", "(", "<", "{"}},
  {'d', {"d", "|)", "|]", "|}"}},
  {'e', {"3", "3", "3", "3"}},
  {'f', {"f", "|=", "ph", "|#"}},
  {'g', {"g", "6", "[", "[+"}},
  {'h', {"h", "4", "|-|", "[-]"}},
  {'i', {"1", "1", "|", "!"}},
  {'j', {"j", "7", "_|", "_/"}},
  {'k', {"k", "|<", "1<", "|{"}},
  {'l', {"l", "1", "|", "|_"}},
  {'m', {"m", "44", "(V)", "|\\/|"}},
  {'n', {"n", "|\\|", "/\\/", "/V"}},
  {'o', {"0", "0", "()", "[]"}},
  {'p', {"p", "/o", "|D", "|o"}},
  {'q', {"q", "9", "O_", "(,)"}},
  {'r', {"r", "12", "12", "|2"}},
  {'s', {"s", "5", "$", "$"}},
  {'t', {"t", "7", "7", "'|'"}},
  {'u', {"u", "|_|", "(_)", "[_]"}},
  {'v', {"v", "\\/", "\\/", "\\/"}},
  {'w', {"w", "VV", "\\/\\/", "(/\\)"}},
  {'x', {"x", "%", ")(", ")("}},
  {'y', {"y", "", "", ""}},
  {'z', {"z", "2", "7_", ">_"}},
  
  {'0', {"D", "0", "D", "0"}},
  {'1', {"I", "I", "L", "L"}},
  {'2', {"Z", "Z", "Z", "e"}},
  {'3', {"E", "E", "E", "E"}},
  {'4', {"h", "h", "A", "A"}},
  {'5', {"S", "S", "S", "S"}},
  {'6', {"b", "b", "G", "G"}},
  {'7', {"T", "T", "j", "j"}},
  {'8', {"X", "X", "X", "X"}},
  {'9', {"g", "g", "j", "j"}}
  
// https://simple.wikipedia.org/wiki/Leet
  };
  
%}
%%
.	{
	  
	  int found = 0;
	  for(int i=0; i<L337SIZE; ++i)
	  {
	  
	    if(l337d1c7[i].c == tolower(*yytext))
	    {
	    
	      int r = 1+(int) (100.0*rand()/(RAND_MAX+1.0));
	    
          if(r<91)
	        printf("%s", l337d1c7[i].leet[0]);
          else if(r<95)
	        printf("%s", l337d1c7[i].leet[1]);
	      else if(r<98)
	        printf("%s", l337d1c7[i].leet[2]);
	      else 
	        printf("%s", l337d1c7[i].leet[3]);

	      found = 1;
	      break;
	    }
	    
	  }
	  
	  if(!found)
	     printf("%c", *yytext);	  
	  
	}
%%
int 
main()
{
  srand(time(NULL)+getpid());
  yylex();
  return 0;
}
]]></programlisting>
        <para>
            A program lényege, hogy minden karakterhez társítunk négy darab hozzá hasonló karaktert/karaktersorozatot, majd egy bekért
            szövegből véletlenszerűen kisorsolunk minden karakternek (ami megtalálható a listában) egyet a párjai közül. 
            Hívhatnánk akár Haxor névgenerátornak is. 
        </para>
        <para>
            A program elején van definiálva a szótárunk, mely az angol ABC betűihez és a számokhoz társít párokat. 
        </para>
        <para>
            Működés közben egész egyszerűen végig lépked a bemenet szövegén karakterről karakterre és ahol egyezik a karakter, ott 
            lecseréli egyre.
            Ahhoz hogy megállapítsuk, hogy az adott karaktert kell e cserélni, a 'found' nevű segédváltozót használjuk, mely ha '1'
            akkor kell cserélni, ha viszont kettő, akkor nem szerepel a szótárban, tehát úgy hagyjuk.
            Azt hogy melyikre, azt egy 1-100 között random generált szám határozza meg. Tehát százalékos esélyek alapján: 
        </para>
        <orderedlist>
            <listitem>
                <para>90%: az első párjára cseréli. </para>
            </listitem>
            <listitem>
                <para>4%: a második párjára cseréli. </para>
            </listitem>
            <listitem>
                <para>3%: a harmadik párjára cseréli. </para>
            </listitem>
            <listitem>
                <para>3%: a negyedik párjára cseréli. </para>
            </listitem>
        </orderedlist>
    </section>                     


    <section>
        <title>A források olvasása</title>
        <para>
            Hogyan olvasod, hogyan értelmezed természetes nyelven az alábbi kódcsipeteket? Például
            <programlisting><![CDATA[if(signal(SIGINT, jelkezelo)==SIG_IGN)
    signal(SIGINT, SIG_IGN);]]></programlisting>
            Ha a SIGINT jel kezelése figyelmen kívül volt hagyva, akkor ezen túl is legyen
            figyelmen kívül hagyva, ha nem volt figyelmen kívül hagyva, akkor a jelkezelo függvény
            kezelje. (Miután a <command>man 7 signal</command> lapon megismertem a SIGINT jelet, a
            <command>man 2 signal</command> lapon pedig a használt rendszerhívást.)
        </para>

        <caution>
            <title>Bugok</title>
            <para>
                Vigyázz, sok csipet kerülendő, mert bugokat visz a kódba! Melyek ezek és miért? 
                Ha nem megy ránézésre, elkapja valamelyiket esetleg a splint vagy a frama?
            </para>
        </caution>
            
        <orderedlist numeration="lowerroman">
            <listitem>                                    
                <programlisting><![CDATA[if(signal(SIGINT, SIG_IGN)!=SIG_IGN)
    signal(SIGINT, jelkezelo);]]></programlisting>
            </listitem>
            <listitem>                                    
                <programlisting><![CDATA[for(i=0; i<5; ++i)]]></programlisting>            
            </listitem>
            <listitem>                                    

                <programlisting><![CDATA[for(i=0; i<5; i++)]]></programlisting>            
            </listitem>
            <listitem>                                    

                <programlisting><![CDATA[for(i=0; i<5; tomb[i] = i++)]]></programlisting>            
            </listitem>
            <listitem>                                    

                <programlisting><![CDATA[for(i=0; i<n && (*d++ = *s++); ++i)]]></programlisting>            
            </listitem>
            <listitem>                                    

                <programlisting><![CDATA[printf("%d %d", f(a, ++a), f(++a, a));]]></programlisting>            
            </listitem>
            <listitem>                                    

                <programlisting><![CDATA[printf("%d %d", f(a), a);]]></programlisting>            
            </listitem>
            <listitem>                                    

                <programlisting><![CDATA[printf("%d %d", f(&a), a);]]></programlisting>            
            </listitem>
        </orderedlist>
        <para>
            Megoldás forrása:  
        </para>

        <para>
            Megoldás videó: 
        </para>

        <orderedlist>
            <listitem>
                <para>Akkor és csakis akkor kezelje a 'jelkezelo' függvény a SIGINT jelet, ha az nincs ignorálva.</para>
            </listitem>
            <listitem>
                <para>Egy for ciklus ami a ötször hajtja végre a hozzá rendelt utasításokat. Preorder módon először az i-t növeli és csak
                    aztán végzi el az utasításokat.</para>
            </listitem>
            <listitem>
                <para>Egy for ciklus ami a ötször hajtja végre a hozzá rendelt utasításokat. Postorder módon először elvégzi az 
                    utasításokat és csak azután növeli az i-t.</para>
            </listitem>
            <listitem>
                <para>Egy for ciklus ami a ötször hajtja végre a hozzá rendelt utasításokat. Viszont a tomb[] első öt értékét 
                    lecseréli az aktuális i értékre. Tehát 0,1,2,3,4. </para>
            </listitem>
            <listitem>
                <para>Egy for ciklus mely annyiszór hajtódik vissza, ameddig <varname>i</varname> kisebb mint <varname>n</varname>
                és a <function>*d++</function> visszatérési értéke valid. (ugye a <varname>d</varname> és <varname>s</varname> azok mutatók)</para>
            </listitem>
            <listitem>
                <para>A standard outputra kiíratjuk az f() függvény visszatérési értékét, decimális számban. </para>
            </listitem>
            <listitem>
                <para>A standard outputra kiíratjuk az f() függvény visszatérési értékét 'a'-ra és magát az 'a'-t is, decimális számban.</para> 
            </listitem>
            <listitem>
                <para>A standard outputra kiíratjuk az f() függvény visszatérési értékét 'a'-ra (mivel annak a memória címére mutatunk)
                    és magát az 'a'-t is, decimális számban. </para>
            </listitem>
        </orderedlist>

    </section>                     

    <section>
        <title>Logikus</title>
        <para>
            Hogyan olvasod természetes nyelven az alábbi Ar nyelvű formulákat?
        </para>
        <programlisting language="tex"><![CDATA[$(\forall x \exists y ((x<y)\wedge(y \text{ prím})))$ 

$(\forall x \exists y ((x<y)\wedge(y \text{ prím})\wedge(SSy \text{ prím})))$ 

$(\exists y \forall x (x \text{ prím}) \supset (x<y)) $ 

$(\exists y \forall x (y<x) \supset \neg (x \text{ prím}))$
]]></programlisting>

            <para>
                Ha lefuttatjuk a 'tex' kódot, akkor jól látszanak az elsőrendű formuláink. Melyek a tavaly tanultak segítségével
                értelmezhetőek. 
            </para>

        <itemizedlist>
            <listitem>
                <para>A prímszámok száma végtelen.</para>
            </listitem>
            <listitem>
                <para>Az ikerprímek száma végtelen.</para>
            </listitem>
            <listitem>
                <para>A prímszámok száma véges.</para>
            </listitem>
            <listitem>
                <para> A prímszámok száma végtelen.</para>
            </listitem>
        </itemizedlist>
        <para>
            Megoldás forrása: <link xlink:href="https://gitlab.com/nbatfai/bhax/blob/master/attention_raising/MatLog_LaTeX">https://gitlab.com/nbatfai/bhax/blob/master/attention_raising/MatLog_LaTeX</link>
        </para>

        <para>
            Megoldás videó: <link xlink:href="https://youtu.be/ZexiPy3ZxsA">https://youtu.be/ZexiPy3ZxsA</link>, <link xlink:href="https://youtu.be/AJSXOQFF_wk">https://youtu.be/AJSXOQFF_wk</link>
        </para>

        <para>
            Tanulságok, tapasztalatok, magyarázat...
        </para>
    </section>                                                                                                                                                                            
          
    <!--
    <section>
        <title>Passz: Deklaráció</title>
            
        <para>
            Vezesd be egy programba (forduljon le) a következőket: 
        </para>

        <itemizedlist>
            <listitem>
                <para>egész</para>                        
            </listitem>
            <listitem>
                <para>egészre mutató mutató</para>                        
            </listitem>
            <listitem>
                <para>egész referenciája</para>                        
            </listitem>
            <listitem>
                <para>egészek tömbje</para>                        
            </listitem>
            <listitem>
                <para>egészek tömbjének referenciája (nem az első elemé)</para>                        
            </listitem>
            <listitem>
                <para>egészre mutató mutatók tömbje</para>                        
            </listitem>
            <listitem>
                <para>egészre mutató mutatót visszaadó függvény</para>                        
            </listitem>
            <listitem>
                <para>egészre mutató mutatót visszaadó függvényre mutató mutató</para>                        
            </listitem>
            <listitem>
                <para>egészet visszaadó és két egészet kapó függvényre mutató mutatót visszaadó, egészet kapó függvény</para>                        
            </listitem>            
            <listitem>
                <para>függvénymutató egy egészet visszaadó és két egészet kapó függvényre mutató mutatót visszaadó, egészet kapó függvényre</para>                        
            </listitem>            
        </itemizedlist>
        
        <programlisting language="c"><![CDATA[ 
            int* getNumPointer(int* numArray);

            int main()
            {
            
                //egész
                int num = 32;
            
                //egészre mutató mutató
                int* toNum = &num;
            
                //egészek tömbje
                int numArray[4] = {0,1,2,3};
            
                //egészek tömbjének referenciája
                int (&numArrayRef)[4] = numArray;
            
                //egészre mutató mutatók tömbje
                int* pointerArray[4];
            
                //egészre mutató mutatót visszaadó függvény
                int* myReactor = getNumPointer(numArray);
            
                //egészre mutató mutatót visszaadó függvényre mutató mutató
                int* (*pointerFUN)(int*) = getNumPointer;
            
                //egészet visszaadó és két egészet kapó függvényre mutató mutatót visszaadó, egészet kapó függvény
                
            
                return 0;
            
            }
            
            int* getNumPointer(int* numArray)
            {
                return numArray;
            }
            ]]>
        </programlisting>

        <para>
            Mit vezetnek be a programba a következő nevek?
        </para>

        <itemizedlist>
            <listitem>
                <programlisting><![CDATA[int a;]]></programlisting>            
            </listitem>
            <listitem>
                <programlisting><![CDATA[int *b = &a;]]></programlisting>            
            </listitem>
            <listitem>
                <programlisting><![CDATA[int &r = a;]]></programlisting>            
            </listitem>
            <listitem>
                <programlisting><![CDATA[int c[5];]]></programlisting>            
            </listitem>
            <listitem>
                <programlisting><![CDATA[int (&tr)[5] = c;]]></programlisting>            
            </listitem>
            <listitem>
                <programlisting><![CDATA[int *d[5];]]></programlisting>            
            </listitem>
            <listitem>
                <programlisting><![CDATA[int *h ();]]></programlisting>            
            </listitem>
            <listitem>
                <programlisting><![CDATA[int *(*l) ();]]></programlisting>            
            </listitem>
            <listitem>
                <programlisting><![CDATA[int (*v (int c)) (int a, int b)]]></programlisting>            
            </listitem>            
            <listitem>
                <programlisting><![CDATA[int (*(*z) (int)) (int, int);]]></programlisting>            
            </listitem>            
        </itemizedlist>       

        <itemizedlist>
            <listitem>
                <para><varname>a</varname> mint egész típusú változó. </para>
            </listitem>
            <listitem>
                <para><varname>a</varname> memória címére mutató mutató.</para>
            </listitem>
            <listitem>
                <para>Egy egészre mutató mutatót <varname>r</varname> névvel, ami az <varname>a</varname> értékét mint mutatócím
                    tartalmazza.</para>
            </listitem>
            <listitem>
                <para>Öt elemű tömb, mely egészekből áll. </para>
            </listitem>
            <listitem>
                <para>Egy 5 elemű, egészeket tartalmazó tömbre mutató mutató, mely a <varname>c</varname> tömbre mutat.</para>
            </listitem>
            <listitem>
                <para>Öt elemű egészekre mutató mutatókból álló tömb. </para>
            </listitem>
            <listitem>
                <para>Egésszel visszatérő, paraméter nélküli függvényre mutató mutató. </para>
            </listitem>
            <listitem>
                <para>Egy egészre mutató mutatóval visszatérő paraméter nélküli függvényre mutató függvénymutató </para>
            </listitem>
            <listitem>
                <para>Egy egésszel visszatérő kettő egészet váró függvényre mutató mutatóval visszatérő, két  egészet váró függvény. </para>
            </listitem>
            <listitem>
                <para>Egy egész számmal visszatérő, két egészel paraméterezet függvényre mutató, egészet váró függvényre mutató mutató.</para>
            </listitem>
        </itemizedlist>

        <para>
            Megoldás videó: 
        </para>
        <para>
            Megoldás forrása:  
        </para>
        <para>
            Az utolsó két deklarációs példa demonstrálására két olyan kódot
            írtunk, amelyek összahasonlítása azt mutatja meg, hogy miért 
            érdemes a <command>typedef</command> használata: <link xlink:href="Chomsky/fptr.c">
                <filename>bhax/thematic_tutorials/bhax_textbook_IgyNeveldaProgramozod/Chomsky/fptr.c</filename>
            </link>,
            <link xlink:href="Chomsky/fptr2.c">
                <filename>bhax/thematic_tutorials/bhax_textbook_IgyNeveldaProgramozod/Chomsky/fptr2.c</filename>.
            </link>  
            
        </para>
        <programlisting><![CDATA[#include <stdio.h>

int
sum (int a, int b)
{
    return a + b;
}

int
mul (int a, int b)
{
    return a * b;
}

int (*sumormul (int c)) (int a, int b)
{
    if (c)
        return mul;
    else
        return sum;

}

int
main ()
{

    int (*f) (int, int);

    f = sum;

    printf ("%d\n", f (2, 3));

    int (*(*g) (int)) (int, int);

    g = sumormul;

    f = *g (42);

    printf ("%d\n", f (2, 3));

    return 0;
}]]></programlisting>            
        <programlisting><![CDATA[#include <stdio.h>

typedef int (*F) (int, int);
typedef int (*(*G) (int)) (int, int);

int
sum (int a, int b)
{
    return a + b;
}

int
mul (int a, int b)
{
    return a * b;
}

F sumormul (int c)
{
    if (c)
        return mul;
    else
        return sum;
}

int
main ()
{

    F f = sum;

    printf ("%d\n", f (2, 3));

    G g = sumormul;

    f = *g (42);

    printf ("%d\n", f (2, 3));

    return 0;
}
]]></programlisting>            
        <para>
            Tanulságok, tapasztalatok, magyarázat...
        </para>
    </section>                     
-->
<section>
    <title>Csiga-Diszkrét mozgási parancsokkal</title>
    <para>
        Ebben a feladatban a diszkrét mozgásba ástuk bele magunkat jobb. A korábbi fejezetben említettem, hogy két féle mozgás típus van: 
        az abszolút és a diszkrét. Össze is hasonlítottam a kettőt, de biztos ami bitos kifejtem megint a diszkrét mozgás lényegét. Tehát itt Steve 
        sokkal pontosabban irányítható mint az abszolút esetén. Egy fordulat pontosan 90 fok és egy lépés pontosan egy blokk. Az abszolúttal 
        ellentétben itt az utasítások után megadható várakozási idő már nem azt határozza meg hogy példáúl mennyi ideig haladjunk előre, pusztán csak 
        azt hogy két utasítás végrehajtása között mennyi időt várjon a kliens. Fontos hogy így sem felesleges, mert ha az utasítások között nem tartunk 
        szünetet, akkor a kliensnek nem lesz ideje feldolgozni egy egy utasítást, mely bugokhoz vagy az ágensünk teljes összeomlásához vezethet. 
    </para>
    <para>
        Ehhez egy későbbi kódot linkkelek, mert abban is ezzel a mozgással dolgozik, viszont kicsit szebb, mint ami eredetileg ide tartozott volna. 
    </para> 
    <programlisting language="python">
<![CDATA[ 
from __future__ import print_function
# ------------------------------------------------------------------------------------------------
# Copyright (c) 2016 Microsoft Corporation
# 
# Permission is hereby granted, free of charge, to any person obtaining a copy of this software and
# associated documentation files (the "Software"), to deal in the Software without restriction,
# including without limitation the rights to use, copy, modify, merge, publish, distribute,
# sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
# 
# The above copyright notice and this permission notice shall be included in all copies or
# substantial portions of the Software.
# 
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT
# NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
# DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
# ------------------------------------------------------------------------------------------------

# Tutorial sample #2: Run simple mission using raw XML

# Added modifications by Norbert Bátfai (nb4tf4i) batfai.norbert@inf.unideb.hu, mine.ly/nb4tf4i.1
# 2018.10.18, https://bhaxor.blog.hu/2018/10/18/malmo_minecraft
# 2020.02.02, NB4tf4i's Red Flowers, http://smartcity.inf.unideb.hu/~norbi/NB4tf4iRedFlowerHell


from builtins import range
import MalmoPython
import os
import sys
import time
import random
import json
import math

if sys.version_info[0] == 2:
    sys.stdout = os.fdopen(sys.stdout.fileno(), 'w', 0)  # flush print output immediately
else:
    import functools
    print = functools.partial(print, flush=True)

# Create default Malmo objects:

agent_host = MalmoPython.AgentHost()
try:
    agent_host.parse( sys.argv )
except RuntimeError as e:
    print('ERROR:',e)
    print(agent_host.getUsage())
    exit(1)
if agent_host.receivedArgument("help"):
    print(agent_host.getUsage())
    exit(0)

# -- set up the mission -- #
missionXML_file='nb4tf4i_d.xml'
with open(missionXML_file, 'r') as f:
    print("NB4tf4i's Red Flowers (Red Flower Hell) - DEAC-Hackers Battle Royale Arena\n")
    print("NB4tf4i vörös pipacsai (Vörös Pipacs Pokol) - DEAC-Hackers Battle Royale Arena\n\n")
    print("The aim of this first challenge, called nb4tf4i's red flowers, is to collect as many red flowers as possible before the lava flows down the hillside.\n")
    print("Ennek az első, az nb4tf4i vörös virágai nevű kihívásnak a célja összegyűjteni annyi piros virágot, amennyit csak lehet, mielőtt a láva lefolyik a hegyoldalon.\n")    
    print("Norbert Bátfai, batfai.norbert@inf.unideb.hu, https://arato.inf.unideb.hu/batfai.norbert/\n\n")    
    print("Loading mission from %s" % missionXML_file)
    mission_xml = f.read()
    my_mission = MalmoPython.MissionSpec(mission_xml, True)
    my_mission.drawBlock( 0, 0, 0, "lava")


class Hourglass:
    def __init__(self, charSet):
        self.charSet = charSet
        self.index = 0
    def cursor(self):
        self.index=(self.index+1)%len(self.charSet)
        return self.charSet[self.index]

hg = Hourglass('|/-\|')

class Steve:
    def __init__(self, agent_host):
        self.agent_host = agent_host
        self.x = 0
        self.y = 0
        self.z = 0        
        self.yaw = 0
        self.pitch = 0
        self.lookingat = 0     
        
    def run(self):
        world_state = self.agent_host.getWorldState()
        # Loop until mission ends:
        j = 1
        i = 3
        
        escape = 0
        move = 13
        ended = 0
        poppy = 0
         
        self.agent_host.sendCommand( "turn -1" )
        time.sleep(1)
        for i in range(4):
            self.agent_host.sendCommand( "move 1" )
            time.sleep(0.1)
        self.agent_host.sendCommand( "look 1" )
        self.agent_host.sendCommand( "move 0" )
        time.sleep(.5)
        self.agent_host.sendCommand( "attack 1" )
        time.sleep(1)
        self.agent_host.sendCommand( "look -1" )
        self.agent_host.sendCommand( "move 1" )
        time.sleep(0.1)
        self.agent_host.sendCommand( "jumpmove 1" )
        time.sleep(0.5)
        self.agent_host.sendCommand( "move 1" )
        time.sleep(0.1)
        #self.agent_host.sendCommand( "look -.2" )

        while world_state.is_mission_running:

            
            print("--- nb4tf4i arena -----------------------------------\n")

        
                    
            if world_state.number_of_observations_since_last_state != 0:
                            
                sensations = world_state.observations[-1].text
                print("    sensations: ", sensations)                
                observations = json.loads(sensations)
                nbr5x5x5 = observations.get("nbr5x5", 0)
                print("    5x5x5 neighborhood of Steve: ", nbr5x5x5)
                            
                if "Yaw" in observations:
                    self.yaw = int(observations["Yaw"])
                if "Pitch" in observations:
                    self.pitch = int(observations["Pitch"])
                if "XPos" in observations:
                    self.x = int(observations["XPos"])
                if "ZPos" in observations:
                    self.z = int(observations["ZPos"])        
                if "YPos" in observations:
                    self.y = int(observations["YPos"])  
                            
                print("    Steve's Coords: ", self.x, self.y, self.z)        
                print("    Steve's Yaw: ", self.yaw)        
                print("    Steve's Pitch: ", self.pitch)

                if "LineOfSight" in observations:
                    LineOfSight = observations["LineOfSight"]
                    self.lookingat = LineOfSight["type"]
                    print("    Steve's <): ", self.lookingat)

                
                #itt van a lényeg amúgy, az első felugrásig a while ciklus előtt van külön megirva
                    
                #if self.lookingat == "flowing_lava": #itt talalkozik a viraggal meg fel is veszi
            
                for i in range(125):
                    if nbr5x5x5[i] == "flowing_lava" or nbr5x5x5[i] == "lava":
                        print("     Lavaaaa!")
                        if escape == 0:
                            self.agent_host.sendCommand( "turn -1" )
                            time.sleep(0.01)
                            self.agent_host.sendCommand( "turn -1" )
                            time.sleep(0.01)
                        escape = 1 #ez az escape igaz hamis hogy kell-e menekülni, akkor már nem ugrik csak fut meg ne forogjon 
                    
                self.agent_host.sendCommand( "move 1" )
                time.sleep(0.01)
                self.agent_host.sendCommand( "move 1" )
                time.sleep(0.01)
                if escape == 0:
                    self.agent_host.sendCommand( "jumpmove 1" )
                    time.sleep(0.5)
                    
                    
            world_state = self.agent_host.getWorldState()
            if self.y < 7 and escape == 1:
                poppy = 1

            if poppy == 1: 
                for i in range(4):
                    self.agent_host.sendCommand( "turn 1" )
                    time.sleep(.1)
                    for j in range(move):
                        
                        if world_state.number_of_observations_since_last_state != 0:
                                
                            sensations = world_state.observations[-1].text
                            print("    sensations: ", sensations)                
                            observations = json.loads(sensations)
                            nbr3x3x3 = observations.get("nbr3x3", 0)
                            print("    3x3x3 neighborhood of Steve: ", nbr3x3x3)
                                
                            if "Yaw" in observations:
                                self.yaw = int(observations["Yaw"])
                            if "Pitch" in observations:
                                self.pitch = int(observations["Pitch"])
                            if "XPos" in observations:
                                self.x = int(observations["XPos"])
                            if "ZPos" in observations:
                                self.z = int(observations["ZPos"])        
                            if "YPos" in observations:
                                self.y = int(observations["YPos"])  
                                
                            print("    Steve's Coords: ", self.x, self.y, self.z)        
                            print("    Steve's Yaw: ", self.yaw)        
                            print("    Steve's Pitch: ", self.pitch)

                            if "LineOfSight" in observations:
                                LineOfSight = observations["LineOfSight"]
                                self.lookingat = LineOfSight["type"]
                            print("    Steve's <): ", self.lookingat)

                
                        

                            if nbr3x3x3[12] == "red_flower" or nbr3x3x3[13] == "red_flower" or nbr3x3x3[14] == "red_flower":
                                if nbr3x3x3[13] == "red_flower":
                                    self.agent_host.sendCommand( "move -1" )
                                    time.sleep(.1) #.5
                                if nbr3x3x3[14] == "red_flower":
                                    self.agent_host.sendCommand( "move 0" )
                                time.sleep(.5) #.5
                                self.agent_host.sendCommand( "look 1" )
                                #self.agent_host.sendCommand( "look .5" )
                                self.agent_host.sendCommand( "move 0" )
                                time.sleep(.5) #.5
                                self.agent_host.sendCommand( "attack 1" )
                                time.sleep(.5) #1
                                self.agent_host.sendCommand( "look -.5" )
                                #self.agent_host.sendCommand( "look -1" )
                                self.agent_host.sendCommand( "jumpmove 1" )
                                time.sleep(0.5)
                            

                        world_state = self.agent_host.getWorldState()
                        '''
                        if self.lookingat == "red_flower": #itt talalkozik a viraggal meg fel is veszi
                            print("     VIRAAAG!")
                            self.agent_host.sendCommand( "move 1" )
                            time.sleep(.5)
                            self.agent_host.sendCommand( "look 1" )
                            self.agent_host.sendCommand( "move 0" )
                            time.sleep(1.5)
                            self.agent_host.sendCommand( "attack 1" )
                            time.sleep(1.5)
                            self.agent_host.sendCommand( "look -1" )
                            self.agent_host.sendCommand( "jumpmove 1" )
                            time.sleep(1)
                        '''
                        #innen kezdodik a mozgasa
                        self.agent_host.sendCommand( "move 1" )
                        time.sleep(0.1)

                    world_state = self.agent_host.getWorldState()

                self.agent_host.sendCommand( "jumpmove 1" )
                time.sleep(0.5)
                self.agent_host.sendCommand( "move 1" )
                time.sleep(0.1)
                move = move + 4 



            


num_repeats = 1
for ii in range(num_repeats):

    my_mission_record = MalmoPython.MissionRecordSpec()

    # Attempt to start a mission:
    max_retries = 6
    for retry in range(max_retries):
        try:
            agent_host.startMission( my_mission, my_mission_record )
            break
        except RuntimeError as e:
            if retry == max_retries - 1:
                print("Error starting mission:", e)
                exit(1)
            else:
                print("Attempting to start the mission:")
                time.sleep(2)

    # Loop until mission starts:
    print("   Waiting for the mission to start ")
    world_state = agent_host.getWorldState()

    while not world_state.has_mission_begun:
        print("\r"+hg.cursor(), end="")
        time.sleep(0.15)
        world_state = agent_host.getWorldState()
        for error in world_state.errors:
            print("Error:",error.text)

    print("NB4tf4i Red Flower Hell running\n")
    steve = Steve(agent_host)
    steve.run()

print("Mission ended")
# Mission has ended.
]]>
    </programlisting>
</section>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        
</chapter>                
